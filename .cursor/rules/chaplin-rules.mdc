---
description: project description
globs: 
---
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.bolt/config.json
.bolt/prompt
.cursor/rules/readme.mdc
.gitignore
.prettierrc
app.json
app/_layout.tsx
app/(auth)/_layout.tsx
app/(auth)/email-auth.tsx
app/(auth)/onboarding.tsx
app/(tabs)/_layout.tsx
app/(tabs)/discover.tsx
app/(tabs)/matches.tsx
app/(tabs)/profile.tsx
app/(tabs)/watched.tsx
app/+not-found.tsx
app/index.tsx
app/matches/[id].tsx
app/movie/[id].tsx
app/movies/_layout.tsx
app/movies/[id].tsx
components/MatchNotification.tsx
components/MovieCard.tsx
components/MovieFilters.tsx
components/profile/EditProfileModal.tsx
components/profile/NotificationsModal.tsx
components/profile/PrivacyModal.tsx
components/Rating.tsx
components/SearchBar.tsx
components/WatchedMovieCard.tsx
contexts/auth.tsx
contexts/theme.tsx
env.d.ts
hooks/useNotifications.ts
lib/auth.ts
lib/firebase.ts
lib/location.ts
lib/matching.ts
lib/matching/matcher.ts
lib/matching/ml-strategy.ts
lib/matching/simple-strategy.ts
lib/matching/types.ts
lib/movies.ts
lib/profile.ts
lib/supabase.ts
lib/supabase/users.ts
lib/tmdb.ts
lib/tmdb/genres.ts
lib/types.ts
package.json
supabase/.gitignore
supabase/config.toml
supabase/migrations/20240320000000_create_initial_schema.sql
tsconfig.json
types/chat.ts
types/env.d.ts
types/matches.ts
types/movies.ts
types/profile.ts

================================================================
Files
================================================================

================
File: .bolt/config.json
================
{
  "template": "bolt-expo"
}

================
File: .bolt/prompt
================
# MovieMate App - Current State & Requirements

## 1. Implemented Core Features

### Authentication & Profile
- Email-based authentication
- User profiles with:
  - First name
  - Avatar upload/management
  - Favorite genres selection
  - Privacy settings
  - Notification preferences

### Movie Discovery
- Swipe interface implemented with:
  - Right swipe: Like/Rate movie
  - Left swipe: Dislike movie
  - Up swipe: Add to watchlist
- Rating system (0-5 stars)
- Movie data integration with TMDB API

### Social Features
- Matching system based on movie preferences
- Match score calculation
- Real-time chat between matched users
- User privacy controls

### Movie Management
- Personal movie lists:
  - Liked movies
  - Watchlist
  - Watch history
- Movie interaction tracking
- Genre-based preferences

## 2. Database Schema

### Core Tables
- profiles: User profile information
- movie_interactions: User movie actions and ratings
- matches: User matching system
- messages: Chat functionality
- user_genres: User genre preferences
- notification_settings: User notification preferences
- privacy_settings: User privacy controls

### Security
- Row Level Security (RLS) implemented
- User-specific data protection
- Authenticated access controls

## 3. Pending Features

### High Priority
- Push notifications for:
  - New matches
  - Chat messages
  - Movie recommendations
- Profile completion flow
- Advanced matching algorithm improvements

### Medium Priority
- Movie night scheduling
- Group chat functionality
- Advanced movie recommendations
- Profile boosting system

### Low Priority
- Geolocation-based matching
- Movie reviews/comments
- Social media integration
- Premium subscription features

## 4. Technical Requirements

### Performance
- Support 50,000+ users
- Handle 1,000+ concurrent sessions
- Real-time chat performance
- Efficient movie data caching

### Security
- Secure file uploads
- Chat message encryption
- User data protection
- API rate limiting

### UX Requirements
- Smooth swipe animations
- Fast image loading
- Responsive design
- Offline support

## 5. Infrastructure

### Current Stack
- React Native (Mobile app)
- Supabase (Backend & Database)
- TMDB API (Movie data)
- Expo (Development framework)

### Monitoring Needs
- User engagement metrics
- Match success rates
- Chat system performance
- API usage tracking

## 6. Future Considerations

### Scalability
- Database optimization
- Caching strategy
- API performance
- Real-time system scaling

### Monetization
- Premium features planning
- Ad integration strategy
- Subscription model design
- In-app purchase system

================
File: .cursor/rules/readme.mdc
================
---
description:
globs:
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to

================
File: .gitignore
================
# dependencies
node_modules/

# expo
.expo/
dist/
web-build/
expo-env.d.ts

# native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macos
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

================
File: .prettierrc
================
{
  "useTabs": false,
  "bracketSpacing": true,
  "singleQuote": true,
  "tabWidth": 2
}

================
File: app.json
================
{
  "expo": {
    "name": "bolt-expo-nativewind",
    "slug": "bolt-expo-nativewind",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "infoPlist": {
        "NSCameraUsageDescription": "This app uses the camera to let you take profile photos.",
        "NSPhotoLibraryUsageDescription": "This app uses the photo library to let you share photos with your matches."
      }
    },
    "web": {
      "bundler": "metro",
      "output": "single",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-image-picker",
        {
          "photosPermission": "The app needs access to your photos to let you share them with your matches.",
          "cameraPermission": "The app needs access to your camera to let you take profile photos."
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "android": {
      "permissions": [
        "CAMERA",
        "READ_EXTERNAL_STORAGE",
        "WRITE_EXTERNAL_STORAGE"
      ]
    }
  }
}

================
File: app/_layout.tsx
================
import { Stack } from 'expo-router';
import { useEffect } from 'react';
import { useRouter, useSegments } from 'expo-router';
import { supabase } from '../lib/supabase';
import { ThemeProvider, useTheme } from '../contexts/theme';
import { AuthProvider } from '../contexts/auth';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

function RootLayoutNav() {
  const router = useRouter();
  const segments = useSegments();
  const { colors } = useTheme();

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      // Auth durumuna göre yönlendirme yap
      const inAuthGroup = segments[0] === '(auth)';
      
      if (session && inAuthGroup) {
        // Oturum açık ve auth sayfalarındaysa ana sayfaya yönlendir
        router.replace('/(tabs)/discover');
      } else if (!session && segments[0] !== '(auth)') {
        // Oturum kapalı ve auth sayfalarında değilse login'e yönlendir
        router.replace('/');
      }
    });

    // Auth state değişikliklerini dinle
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      const inAuthGroup = segments[0] === '(auth)';

      if (session && inAuthGroup) {
        router.replace('/(tabs)/discover');
      } else if (!session && segments[0] !== '(auth)') {
        router.replace('/');
      }
    });

    return () => subscription.unsubscribe();
  }, [segments]);

  return (
    <Stack
      screenOptions={{
        headerStyle: {
          backgroundColor: colors.surface,
        },
        headerTintColor: colors.text,
      }}
    >
      {/* Ana sayfa olarak email-auth */}
      <Stack.Screen name="index" options={{ headerShown: false }} />
      
      {/* Diğer sayfalar */}
      <Stack.Screen name="(auth)" options={{ headerShown: false }} />
      <Stack.Screen name="(tabs)" options={{ headerShown: false, gestureEnabled: false }} />
      <Stack.Screen
        name="matches/[id]"
        options={{
          presentation: 'modal',
          headerTitle: "Chat",
          headerShown: true,
        }}
      />
    </Stack>
  );
}

export default function RootLayout() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <GestureHandlerRootView style={styles.container}>
          <RootLayoutNav />
        </GestureHandlerRootView>
      </ThemeProvider>
    </AuthProvider>
  );
}

// Başlangıç sayfasını belirt
export const unstable_settings = {
  initialRouteName: '(auth)',
};

================
File: app/(auth)/_layout.tsx
================
import { Stack } from 'expo-router';

export default function AuthLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      <Stack.Screen 
        name="email-auth"
        options={{
          title: 'Sign In',
        }}
      />
      <Stack.Screen 
        name="onboarding"
        options={{
          title: 'Welcome',
          gestureEnabled: false
        }}
      />
    </Stack>
  );
}

// Auth grubunun başlangıç sayfası
export const unstable_settings = {
  initialRouteName: 'email-auth',
};

================
File: app/(auth)/email-auth.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Alert,
  Image,
  Animated,
  Dimensions,
} from 'react-native';
import { router } from 'expo-router';
import { supabase } from '../../lib/supabase';
import { TMDB_IMAGE_URL } from '../../lib/tmdb';

const { width } = Dimensions.get('window');
const GRID_SIZE = 3; // 3x3 grid
const POSTER_SIZE = width / GRID_SIZE;

interface MoviePoster {
  id: number;
  poster_path: string;
}

export default function EmailAuthScreen() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [posters, setPosters] = useState<MoviePoster[]>([]);
  const [currentPosters, setCurrentPosters] = useState<MoviePoster[]>([]);
  const [nextPosters, setNextPosters] = useState<MoviePoster[]>([]);
  const fadeAnim = React.useRef(new Animated.Value(1)).current;

  // Film posterlerini yükle
  useEffect(() => {
    const loadMoviePosters = async () => {
      try {
        const response = await fetch(
          'https://api.themoviedb.org/3/movie/popular?language=en-US&page=1',
          {
            headers: {
              'Authorization': `Bearer ${process.env.EXPO_PUBLIC_TMDB_ACCESS_TOKEN}`,
              'Content-Type': 'application/json'
            }
          }
        );
        const data = await response.json();
        const validPosters = data.results
          .filter((movie: any) => movie.poster_path)
          .map((movie: any) => ({
            id: movie.id,
            poster_path: movie.poster_path
          }));
        setPosters(validPosters);
        setCurrentPosters(validPosters.slice(0, 9));
        setNextPosters(validPosters.slice(9, 18));
      } catch (error) {
        console.error('Error loading movie posters:', error);
      }
    };

    loadMoviePosters();
  }, []);

  // Posterleri değiştir
  useEffect(() => {
    if (posters.length === 0) return;

    const changePosterInterval = setInterval(() => {
      Animated.sequence([
        // Mevcut posterleri soldur
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 1000,
          useNativeDriver: true,
        }),
        // Yeni posterleri göster
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        })
      ]).start(() => {
        // Posterleri güncelle
        setCurrentPosters(nextPosters);
        const nextIndex = (posters.indexOf(nextPosters[8]) + 1) % posters.length;
        setNextPosters(posters.slice(nextIndex, nextIndex + 9));
      });
    }, 5000);

    return () => clearInterval(changePosterInterval);
  }, [posters, nextPosters]);

  const handleSignIn = async () => {
    try {
      setLoading(true);
      setError(null);
      
      if (!email) {
        throw new Error('Please enter your email');
      }

      const { error } = await supabase.auth.signInWithOtp({
        email: email,
        options: {
          emailRedirectTo: 'moviemate://onboarding'
        }
      });
      
      if (error) throw error;

      // Başarılı mesajı göster
      Alert.alert(
        'Check your email',
        'We sent you a magic link to sign in',
        [{ text: 'OK' }]
      );

    } catch (err: any) {
      console.error('Error signing in:', err);
      setError(err.message || 'Failed to sign in');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      {/* Arka plan grid'i */}
      <Animated.View style={[styles.backgroundGrid, { opacity: fadeAnim }]}>
        {currentPosters.map((movie, index) => (
          <Image
            key={`${movie.id}-${index}`}
            source={{ uri: `${TMDB_IMAGE_URL}/w342${movie.poster_path}` }}
            style={styles.posterImage}
            blurRadius={Platform.OS === 'ios' ? 10 : 5}
          />
        ))}
      </Animated.View>

      {/* Karartma katmanı */}
      <View style={styles.overlay} />

      {/* Login formu */}
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.content}
      >
        <View style={styles.formContainer}>
          <View style={styles.logoContainer}>
            <Text style={styles.title}>MovieMate</Text>
            <Text style={styles.subtitle}>Find your perfect movie match</Text>
          </View>
          
          {error && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          )}

          <TextInput
            style={styles.input}
            placeholder="Email address"
            placeholderTextColor="rgba(255,255,255,0.6)"
            value={email}
            onChangeText={setEmail}
            keyboardType="email-address"
            autoCapitalize="none"
            editable={!loading}
          />

          <TouchableOpacity
            style={[styles.button, loading && styles.buttonDisabled]}
            onPress={handleSignIn}
            disabled={loading || !email.trim()}
          >
            {loading ? (
              <ActivityIndicator color="#fff" />
            ) : (
              <Text style={styles.buttonText}>Continue with Email</Text>
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  backgroundGrid: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  posterImage: {
    width: POSTER_SIZE,
    height: POSTER_SIZE * 1.5,
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0,0,0,0.7)',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  formContainer: {
    width: '100%',
    maxWidth: 400,
    alignSelf: 'center',
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 40,
  },
  title: {
    fontSize: 40,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 18,
    color: 'rgba(255,255,255,0.8)',
    textAlign: 'center',
    marginBottom: 30,
  },
  errorContainer: {
    backgroundColor: 'rgba(255,59,48,0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 15,
  },
  errorText: {
    color: '#ff3b30',
    textAlign: 'center',
    fontSize: 14,
  },
  input: {
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    color: '#fff',
    fontSize: 16,
  },
  button: {
    backgroundColor: '#e50914',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginBottom: 16,
  },
  buttonDisabled: {
    opacity: 0.7,
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
});

================
File: app/(auth)/onboarding.tsx
================
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
} from 'react-native';
import { router } from 'expo-router';
import { supabase } from '../../lib/supabase';

export default function OnboardingScreen() {
  const [firstName, setFirstName] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleComplete = async () => {
    try {
      setLoading(true);
      setError(null);

      if (!firstName.trim()) {
        throw new Error('Please enter your name');
      }

      // Mevcut kullanıcıyı al
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) throw new Error('No authenticated user found');

      // Profili güncelle
      const { error: updateError } = await supabase
        .from('profiles')
        .update({
          first_name: firstName.trim(),
          updated_at: new Date().toISOString()
        })
        .eq('id', user.id);

      if (updateError) throw updateError;

      // Ana sayfaya yönlendir
      router.replace('/(tabs)/discover');

    } catch (err: any) {
      console.error('Error completing onboarding:', err);
      setError(err.message || 'Failed to complete onboarding');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Welcome!</Text>
      <Text style={styles.subtitle}>Let's get to know you better</Text>

      {error && (
        <Text style={styles.errorText}>{error}</Text>
      )}

      <TextInput
        style={styles.input}
        placeholder="Your Name"
        placeholderTextColor="#999"
        value={firstName}
        onChangeText={setFirstName}
        autoFocus
      />

      <TouchableOpacity
        style={[styles.button, loading && styles.buttonDisabled]}
        onPress={handleComplete}
        disabled={loading || !firstName.trim()}
      >
        {loading ? (
          <ActivityIndicator color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Continue</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
    backgroundColor: '#1a1a1a',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 10,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    color: '#ccc',
    marginBottom: 30,
    textAlign: 'center',
  },
  input: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    color: '#fff',
    fontSize: 16,
  },
  button: {
    backgroundColor: '#e50914',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
  },
  buttonDisabled: {
    opacity: 0.7,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  errorText: {
    color: '#ff6b6b',
    textAlign: 'center',
    marginBottom: 20,
  },
});

================
File: app/(tabs)/_layout.tsx
================
import { Tabs } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from '../../contexts/theme';

export default function TabLayout() {
  const { colors, isDark } = useTheme();

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarStyle: {
          backgroundColor: colors.background,
          borderTopColor: colors.border,
        },
        tabBarActiveTintColor: colors.primary,
        tabBarInactiveTintColor: colors.textSecondary,
      }}>
      <Tabs.Screen
        name="discover"
        options={{
          title: 'Discover',
          tabBarIcon: ({ size, color }) => (
            <MaterialCommunityIcons name="movie-open" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="watched"
        options={{
          title: 'Library',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="bookmark-multiple" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="matches"
        options={{
          title: 'Matches',
          tabBarIcon: ({ size, color }) => (
            <MaterialCommunityIcons name="heart" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="profile"
        options={{
          title: 'Profile',
          tabBarIcon: ({ size, color }) => (
            <MaterialCommunityIcons name="account" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================
File: app/(tabs)/discover.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, Text, ActivityIndicator, Dimensions, TouchableOpacity, StyleSheet, Modal, TouchableWithoutFeedback } from 'react-native';
import { useAuth } from '../../contexts/auth';
import { supabase } from '../../lib/supabase';
import Animated, {
  useAnimatedGestureHandler,
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';
import { PanGestureHandler, GestureHandlerRootView } from 'react-native-gesture-handler';
import type { PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';
import MovieCard from '../../components/MovieCard';
import { Movie, getPopularMovies, getTopRatedMovies, getTrendingMovies, getUpcomingMovies } from '../../lib/tmdb';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from '../../contexts/theme';
import { MovieMatcher } from '../../lib/matching/matcher';
import { Rating } from '../../components/Rating';

const SWIPE_THRESHOLD = 100;
const SCREEN_WIDTH = Dimensions.get('window').width;
const SCREEN_HEIGHT = Dimensions.get('window').height;

type MovieAction = 'watched' | 'watchlist' | 'liked' | 'disliked' | 'skip';

export default function DiscoverScreen() {
  const [movies, setMovies] = useState<Movie[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [loading, setLoading] = useState(true);
  const [isAnimating, setIsAnimating] = useState(false);
  const [showNextCard, setShowNextCard] = useState(false);
  const { user } = useAuth();
  const { colors } = useTheme();
  const [currentRating, setCurrentRating] = useState<number>(0);
  const [showRating, setShowRating] = useState(false);
  const [selectedMovie, setSelectedMovie] = useState<Movie | null>(null);

  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);

  useEffect(() => {
    loadInitialMovies();
  }, []);

  const loadInitialMovies = async () => {
    try {
      setLoading(true);
      const success = await loadMovies();
      if (!success) {
        console.error('Failed to load initial movies');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (movies.length > 0 && !isAnimating) {
      translateX.value = 0;
      translateY.value = 0;
      setShowNextCard(false);
    }
  }, [currentIndex, isAnimating]);

  useEffect(() => {
    let isMounted = true;

    const loadRating = async () => {
      try {
        if (!user?.id || !movies[currentIndex]?.id) return;

        const { data, error } = await supabase
          .from('movie_interactions')
          .select('action')
          .eq('user_id', user.id)
          .eq('movie_id', movies[currentIndex].id)
          .maybeSingle();

        if (error) throw error;

        if (isMounted) {
          // liked veya watched ise 5 yıldız, değilse 0
          setCurrentRating(
            data?.action === 'liked' || data?.action === 'watched' ? 5 : 0
          );
        }
      } catch (error) {
        console.error('Error loading rating:', error);
      }
    };

    loadRating();

    return () => {
      isMounted = false;
    };
  }, [currentIndex, user?.id, movies]);

  const loadMovies = useCallback(async () => {
    try {
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return false;

      // Tüm etkileşimleri al (sadece movie_id'leri)
      const { data: interactedMovies, error: interactionsError } = await supabase
        .from('movie_interactions')
        .select('movie_id')
        .eq('user_id', user.id);

      if (interactionsError) throw interactionsError;

      // Mevcut filmlerin ID'lerini de ekle
      const interactedMovieIds = new Set([
        ...(interactedMovies?.map(m => m.movie_id) || []),
        ...movies.map(m => m.id) // Mevcut filmleri de ekle
      ]);

      const categories = [
        { name: 'popular', fetch: getPopularMovies },
        { name: 'top rated', fetch: getTopRatedMovies },
        { name: 'trending', fetch: getTrendingMovies },
        { name: 'upcoming', fetch: getUpcomingMovies }
      ];

      let filteredMovies: Movie[] = [];
      
      for (const category of categories) {
        const movies = await category.fetch();
        const filtered = movies.filter(movie => !interactedMovieIds.has(movie.id));
        
        if (filtered.length > 0) {
          filteredMovies = filtered;
          break;
        }

        for (let page = 2; page <= 5; page++) {
          const nextPageMovies = await category.fetch(page);
          const filteredNextPage = nextPageMovies.filter(movie => !interactedMovieIds.has(movie.id));
          
          if (filteredNextPage.length > 0) {
            filteredMovies = filteredNextPage;
            break;
          }
        }

        if (filteredMovies.length > 0) break;
      }

      if (filteredMovies.length > 0) {
        // Mevcut filmleri temizle ve yeni filmleri ekle
        setMovies(filteredMovies);
        setCurrentIndex(0); // Index'i sıfırla
        return true;
      }

      return false;
    } catch (error) {
      console.error('Error in loadMovies:', error);
      return false;
    }
  }, [movies]); // movies'i dependency array'e ekle

  const handleMovieAction = async (action: MovieAction) => {
    if (isAnimating || !movies[currentIndex]) return;

    try {
      setIsAnimating(true);

      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      // Eğer like ise rating modalını göster
      if (action === 'liked') {
        setSelectedMovie(movies[currentIndex]);
        setShowRating(true);
        return;
      }

      // Film etkileşimini kaydet
      const { error: interactionError } = await supabase
        .from('movie_interactions')
        .upsert({
          user_id: user.id,
          movie_id: movies[currentIndex].id,
          title: movies[currentIndex].title || 'Unknown Movie',
          poster_path: movies[currentIndex].poster_path || '/default-poster.jpg',
          action: action,
          created_at: new Date().toISOString()
        });

      if (interactionError) {
        console.error('Error saving interaction:', interactionError);
        throw interactionError;
      }

      // Sonraki filme geç
      setCurrentIndex(prev => prev + 1);

      // Film sayısı azaldıysa yeni filmler yükle
      if (currentIndex >= movies.length - 2) {
        loadMovies();
      }
    } catch (error) {
      console.error('Error in handleAction:', error);
    } finally {
      setIsAnimating(false);
    }
  };

  const handleRating = async (rating: number) => {
    try {
      if (!user?.id || !selectedMovie) return;

      // Film etkileşimini kaydet
      const { error: interactionError } = await supabase
        .from('movie_interactions')
        .upsert({
          user_id: user.id,
          movie_id: selectedMovie.id,
          title: selectedMovie.title || 'Unknown Movie',
          poster_path: selectedMovie.poster_path || '/default-poster.jpg',
          action: rating >= 3 ? 'liked' : 'disliked',
          rating: rating,
          created_at: new Date().toISOString()
        });

      if (interactionError) throw interactionError;

      setCurrentRating(rating);
      setShowRating(false);
      setSelectedMovie(null);
      setCurrentIndex(prev => prev + 1);

      if (currentIndex >= movies.length - 2) {
        loadMovies();
      }
    } catch (error) {
      console.error('Error saving rating:', error);
    } finally {
      setIsAnimating(false);
    }
  };

  const handleSkip = () => {
    setShowRating(false);
    setSelectedMovie(null);
    setIsAnimating(false);
  };

  const handleSwipeRight = () => {
    translateX.value = withSpring(SCREEN_WIDTH * 1.5, {
      damping: 20,
      stiffness: 100,
    });

    setTimeout(() => {
      translateX.value = 0;
      translateY.value = 0;
      setIsAnimating(false);
      setShowRating(true);
    }, 300);
  };

  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent>({
    onStart: () => {
      // Başlangıç pozisyonunu kaydet
    },
    onActive: (event) => {
      translateX.value = event.translationX;
      translateY.value = event.translationY;
    },
    onEnd: (event) => {
      if (event.translationX > SWIPE_THRESHOLD) {
        runOnJS(setIsAnimating)(true);
        runOnJS(handleSwipeRight)();
      } else if (event.translationX < -SWIPE_THRESHOLD) {
        runOnJS(setIsAnimating)(true);
        translateX.value = withSpring(-SCREEN_WIDTH * 1.5, {
          damping: 20,
          stiffness: 100,
        }, () => {
          runOnJS(handleMovieAction)('disliked');
        });
      } else if (event.translationY < -SWIPE_THRESHOLD) {
        runOnJS(setIsAnimating)(true);
        translateY.value = withSpring(-SCREEN_HEIGHT, {
          damping: 20,
          stiffness: 100,
        }, () => {
          runOnJS(handleMovieAction)('watchlist');
        });
      } else {
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
        runOnJS(setIsAnimating)(false);
      }
    },
  });

  const currentCardStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${(translateX.value / SCREEN_WIDTH) * 20}deg` },
    ],
  }));

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    content: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
    },
    cardWrapper: {
      flex: 1,
      width: '100%',
      alignItems: 'center',
      justifyContent: 'center',
    },
    cardContainer: {
      width: SCREEN_WIDTH * 0.9,
      height: SCREEN_HEIGHT * 0.85,
      maxWidth: 400,
      position: 'relative',
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorText: {
      color: colors.text,
      fontSize: 16,
      textAlign: 'center',
    },
    noContentTitle: {
      fontSize: 24,
      fontWeight: 'bold',
      marginBottom: 10,
    },
    noContentSubtitle: {
      fontSize: 16,
    },
    ratingModalContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
    },
    ratingModalContent: {
      position: 'relative',
      backgroundColor: colors.surface,
      padding: 30,
      borderRadius: 20,
      alignItems: 'center',
      width: Math.min(350, SCREEN_WIDTH * 0.85),
      marginHorizontal: 20,
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    ratingContainer: {
      padding: 20,
      alignItems: 'center',
    },
    ratingTitle: {
      fontSize: 28,
      fontWeight: 'bold',
      marginBottom: 24,
      textAlign: 'center',
    },
    skipButton: {
      marginTop: 24,
      padding: 12,
    },
    skipText: {
      fontSize: 16,
      fontWeight: '500',
    },
  });

  if (loading) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <ActivityIndicator size="large" color={colors.primary} />
      </View>
    );
  }

  if (!movies.length) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <MaterialCommunityIcons 
          name="movie-off" 
          size={64} 
          color={colors.textSecondary} 
        />
        <Text style={[styles.noContentTitle, { color: colors.text }]}>
          No Movies Available
        </Text>
        <Text style={[styles.noContentSubtitle, { color: colors.textSecondary }]}>
          Please try again later
        </Text>
      </View>
    );
  }

  if (currentIndex >= movies.length) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Text style={styles.errorText}>Loading more movies...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <GestureHandlerRootView style={{ flex: 1 }}>
        <View style={styles.content}>
          <View style={styles.cardWrapper}>
            <View style={styles.cardContainer}>
              {currentIndex + 1 < movies.length && (
                <View style={[StyleSheet.absoluteFill, { zIndex: 0 }]}>
                  <MovieCard
                    movie={movies[currentIndex + 1]}
                    onAction={handleMovieAction}
                    isAnimating={isAnimating}
                  />
                </View>
              )}
              {currentIndex < movies.length && (
                <PanGestureHandler onGestureEvent={gestureHandler}>
                  <Animated.View style={[StyleSheet.absoluteFill, { zIndex: 1 }, currentCardStyle]}>
                    <MovieCard
                      movie={movies[currentIndex]}
                      onAction={handleMovieAction}
                      isAnimating={isAnimating}
                    />
                  </Animated.View>
                </PanGestureHandler>
              )}
            </View>
          </View>
        </View>
      </GestureHandlerRootView>

      <Modal
        visible={showRating}
        transparent
        animationType="fade"
        statusBarTranslucent
        onRequestClose={handleSkip}
      >
        <View style={styles.ratingModalContainer}>
          <View 
            style={[
              styles.ratingModalContent, 
              { backgroundColor: colors.surface }
            ]}
          >
            <Text style={[styles.ratingTitle, { color: colors.text }]}>
              Rate this movie
            </Text>
            <View style={styles.ratingContainer}>
              <Rating
                rating={currentRating}
                onRate={handleRating}
                size={44}
                disabled={isAnimating}
              />
            </View>
            <TouchableOpacity
              style={styles.skipButton}
              onPress={handleSkip}
            >
              <Text style={[styles.skipText, { color: colors.textSecondary }]}>
                Skip
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
}

================
File: app/(tabs)/matches.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Dimensions,
  ScrollView,
  SafeAreaView,
  Platform,
} from 'react-native';
import { useAuth } from '../../contexts/auth';
import { useTheme } from '../../contexts/theme';
import { supabase } from '../../lib/supabase';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { TMDB_IMAGE_URL } from '../../lib/tmdb';

const { width } = Dimensions.get('window');

interface MovieData {
  id: number;
  title: string;
  poster_path: string | null;
}

interface CommonMovie {
  movie_id: number;
  movies: MovieData;
}

interface Match {
  id: number;
  user: {
    id: string;
    first_name: string;
    avatar_url: string | null;
  };
  match_score: number;
  common_movies: MovieData[];
  created_at: string;
  last_message?: {
    content: string;
    created_at: string;
    sender_id: string;
  };
}

export default function MatchesScreen() {
  const [matches, setMatches] = useState<Match[]>([]);
  const [loading, setLoading] = useState(true);
  const { user } = useAuth();
  const { colors } = useTheme();

  useEffect(() => {
    loadMatches();
  }, []);

  const loadMatches = async () => {
    try {
      setLoading(true);
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      const { data: matchData, error: matchError } = await supabase
        .from('matches')
        .select('*')
        .or(`user1_id.eq.${user.id},user2_id.eq.${user.id}`)
        .eq('status', 'accepted')
        .order('match_score', { ascending: false });

      if (matchError) throw matchError;

      const matchPromises = matchData.map(async (match) => {
        const otherUserId = match.user1_id === user.id ? match.user2_id : match.user1_id;

        // Profil bilgilerini al
        const { data: profileData, error: profileError } = await supabase
          .from('profiles')
          .select('id, first_name, avatar_url')
          .eq('id', otherUserId)
          .single();

        if (profileError) {
          console.error('Error loading profile:', profileError);
          return null;
        }

        // Son mesajı al
        const { data: lastMessageData, error: messageError } = await supabase
          .from('messages')
          .select('content, created_at, sender_id')
          .eq('match_id', match.id)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        // Ortak filmleri al
        const { data: commonMovies, error: moviesError } = await supabase
          .from('movie_interactions')
          .select('movie_id, title, poster_path')
          .eq('user_id', user.id)
          .eq('action', 'liked')
          .in('movie_id', (
            await supabase
              .from('movie_interactions')
              .select('movie_id')
              .eq('user_id', otherUserId)
              .eq('action', 'liked')
          ).data?.map(m => m.movie_id) || []);

        if (moviesError) {
          console.error('Error loading common movies:', moviesError);
          return null;
        }

        return {
          id: match.id,
          user: {
            id: profileData.id,
            first_name: profileData.first_name,
            avatar_url: profileData.avatar_url
          },
          match_score: match.match_score,
          common_movies: commonMovies.map(m => ({
            id: m.movie_id,
            title: m.title,
            poster_path: m.poster_path
          })),
          created_at: match.created_at,
          last_message: lastMessageData || undefined
        };
      });

      const results = await Promise.all(matchPromises);
      const validMatches = results.filter((match): match is Match => match !== null);
      setMatches(validMatches);

    } catch (error) {
      console.error('Error loading matches:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderMatch = ({ item }: { item: Match }) => (
    <TouchableOpacity
      style={[styles.matchCard, { backgroundColor: colors.surface }]}
      onPress={() => {
        router.push({
          pathname: '/matches/[id]',
          params: { id: item.id }
        });
      }}
    >
      <View style={styles.matchHeader}>
        <View style={styles.userInfo}>
          {item.user.avatar_url ? (
            <Image
              source={{ uri: item.user.avatar_url }}
              style={styles.avatar}
            />
          ) : (
            <View style={[styles.avatarPlaceholder, { backgroundColor: colors.primary }]}>
              <Text style={styles.avatarText}>
                {item.user.first_name.substring(0, 2).toUpperCase()}
              </Text>
            </View>
          )}
          <View style={styles.userDetails}>
            <Text style={[styles.userName, { color: colors.text }]}>
              {item.user.first_name}
            </Text>
            {item.last_message ? (
              <Text 
                style={[styles.lastMessage, { color: colors.textSecondary }]}
                numberOfLines={1}
              >
                {item.last_message.sender_id === user?.id ? 'You: ' : ''}{item.last_message.content}
              </Text>
            ) : (
              <Text style={[styles.matchScore, { color: colors.textSecondary }]}>
                {item.match_score} movies in common
              </Text>
            )}
          </View>
        </View>
        <MaterialCommunityIcons
          name="chat"
          size={24}
          color={colors.primary}
        />
      </View>

      {item.common_movies.length > 0 && (
        <>
          <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>
            Common Movies ({item.common_movies.length})
          </Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.movieList}
          >
            {item.common_movies.map((movie, index) => (
              <TouchableOpacity
                key={`${movie.id}-${index}`}
                style={styles.movieCard}
                onPress={() => router.push({
                  pathname: '/movie/[id]',
                  params: { id: movie.id }
                })}
              >
                <Image
                  source={{
                    uri: movie.poster_path
                      ? `${TMDB_IMAGE_URL}/w342${movie.poster_path}`
                      : 'https://via.placeholder.com/342x513'
                  }}
                  style={styles.moviePoster}
                  resizeMode="cover"
                />
                <Text 
                  style={[styles.movieTitle, { color: colors.text }]} 
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {movie.title}
                </Text>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </>
      )}
    </TouchableOpacity>
  );

  if (loading) {
    return (
      <SafeAreaView style={[styles.safeArea, { backgroundColor: colors.background }]}>
        <View style={[styles.container, styles.centered]}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      </SafeAreaView>
    );
  }

  if (matches.length === 0) {
    return (
      <SafeAreaView style={[styles.safeArea, { backgroundColor: colors.background }]}>
        <View style={[styles.container, styles.centered]}>
          <MaterialCommunityIcons
            name="account-multiple"
            size={64}
            color={colors.textSecondary}
          />
          <Text style={[styles.emptyText, { color: colors.text }]}>
            No matches yet
          </Text>
          <Text style={[styles.emptySubtext, { color: colors.textSecondary }]}>
            Like more movies to find matches!
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={[styles.safeArea, { backgroundColor: colors.background }]}>
      <View style={styles.container}>
        <FlatList
          data={matches}
          renderItem={renderMatch}
          keyExtractor={(item) => item.id.toString()}
          contentContainerStyle={styles.list}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    paddingTop: Platform.OS === 'ios' ? 0 : 0,
  },
  container: {
    flex: 1,
  },
  centered: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  list: {
    padding: 16,
  },
  matchCard: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  matchHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    gap: 12,
    marginRight: 12,
  },
  avatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
  },
  avatarPlaceholder: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  userDetails: {
    flex: 1,
    justifyContent: 'center',
  },
  userName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 2,
  },
  matchScore: {
    fontSize: 14,
  },
  sectionTitle: {
    fontSize: 14,
    marginBottom: 8,
    marginTop: 8,
    fontWeight: '600',
  },
  movieList: {
    paddingVertical: 8,
    gap: 12,
  },
  movieCard: {
    width: 120,
    marginRight: 12,
  },
  moviePoster: {
    width: 120,
    height: 180,
    borderRadius: 8,
    marginBottom: 8,
    backgroundColor: '#eee',
  },
  movieTitle: {
    fontSize: 13,
    textAlign: 'center',
    lineHeight: 18,
    paddingHorizontal: 4,
  },
  separator: {
    height: 16,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 16,
    textAlign: 'center',
  },
  lastMessage: {
    fontSize: 14,
    color: 'gray',
    marginTop: 2,
    paddingRight: 8,
  },
});

================
File: app/(tabs)/profile.tsx
================
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, Image, ScrollView, StyleSheet, RefreshControl, Dimensions, ActivityIndicator, Alert, Platform, Linking } from 'react-native';
import { router } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAuth } from '../../contexts/auth';
import { useTheme } from '../../contexts/theme';
import { movieGenres } from '../../lib/tmdb/genres';
import { supabase } from '../../lib/supabase';
import { EditProfileModal } from '../../components/profile/EditProfileModal';
import { NotificationsModal } from '../../components/profile/NotificationsModal';
import { PrivacyModal } from '../../components/profile/PrivacyModal';
import { useNotifications } from '../../hooks/useNotifications';
import * as ImagePicker from 'expo-image-picker';
import { decode } from 'base64-arraybuffer';
import type { Profile } from '../../types/profile';

const { width } = Dimensions.get('window');
const STAT_SIZE = (width - 48) / 2;

interface MovieInteraction {
  movie_id: number;
  action: 'watched' | 'watchlist' | 'liked' | 'disliked';
  rating?: number;
  created_at: string;
  movies: {
    id: number;
    title: string;
    poster_path: string;
    genre_ids: number[];
  };
}

interface Stats {
  watched: number;
  liked: number;
  disliked: number;
  watchlist: number;
  totalMovies: number;
  averageRating: number;
  topGenres: { genre: string; count: number }[];
  recentMovies: {
    id: number;
    title: string;
    poster_path: string;
    rating: number;
    created_at: string;
  }[];
}

export default function ProfileScreen() {
  const [isLoading, setIsLoading] = useState(false);
  const { user, signOut } = useAuth();
  const { colors } = useTheme();
  const [selectedGenres, setSelectedGenres] = useState<string[]>([]);
  const [loadingGenres, setLoadingGenres] = useState(true);
  const [stats, setStats] = useState<Stats | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showEditProfile, setShowEditProfile] = useState(false);
  const [showNotifications, setShowNotifications] = useState(false);
  const [showPrivacy, setShowPrivacy] = useState(false);
  const [notificationSettings, setNotificationSettings] = useState({
    newMatches: true,
    newMessages: true,
    movieSuggestions: true,
  });
  const [privacySettings, setPrivacySettings] = useState({
    profileVisible: true,
    showRatings: true,
  });
  const { notifications, loading: notificationsLoading } = useNotifications();
  const [profile, setProfile] = useState<Profile | null>(null);
  const [uploading, setUploading] = useState(false);

  useEffect(() => {
    if (user?.id) {
      loadUserGenres();
      loadStats();
    }
    checkPermissions();
  }, [user?.id]);

  const handleSignOut = async () => {
    setIsLoading(true);
    await signOut();
    router.replace('/(auth)/phone-auth');
  };

  const getInitials = (name: string) => {
    return name.substring(0, 2).toUpperCase();
  };

  const loadUserGenres = async () => {
    try {
      const { data: userGenres, error } = await supabase
        .from('user_genres')
        .select('genre_id')
        .eq('firebase_uid', user!.id);

      if (error) throw error;

      setSelectedGenres(userGenres?.map(g => g.genre_id.toString()) || []);
    } catch (error) {
      console.error('Error loading user genres:', error);
    } finally {
      setLoadingGenres(false);
    }
  };

  const toggleGenre = async (genreId: string) => {
    try {
      setLoadingGenres(true);
      if (selectedGenres.includes(genreId)) {
        // Remove genre
        const { error } = await supabase
          .from('user_genres')
          .delete()
          .eq('firebase_uid', user!.id)
          .eq('genre_id', genreId);

        if (error) throw error;
        setSelectedGenres(prev => prev.filter(id => id !== genreId));
      } else {
        // Add genre
        const { error } = await supabase
          .from('user_genres')
          .insert({
            firebase_uid: user!.id,
            genre_id: genreId
          });

        if (error) throw error;
        setSelectedGenres(prev => [...prev, genreId]);
      }
    } catch (error) {
      console.error('Error toggling genre:', error);
    } finally {
      setLoadingGenres(false);
    }
  };

  const loadStats = async () => {
    try {
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      // Film etkileşimlerini al
      const { data: interactionsData, error: interactionsError } = await supabase
        .from('movie_interactions')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (interactionsError) throw interactionsError;

      // Film detaylarını TMDB'den al
      const moviePromises = interactionsData.map(async (interaction) => {
        try {
          const response = await fetch(
            `https://api.themoviedb.org/3/movie/${interaction.movie_id}`,
            {
              headers: {
                'Authorization': `Bearer ${process.env.EXPO_PUBLIC_TMDB_ACCESS_TOKEN}`,
                'Content-Type': 'application/json'
              }
            }
          );

          if (!response.ok) {
            throw new Error(`TMDB API error: ${response.status}`);
          }

          const movieData = await response.json();
          console.log('Movie data:', movieData); // Debug için

          return {
            ...interaction,
            movie: {
              id: movieData.id,
              title: movieData.title,
              poster_path: movieData.poster_path,
              genre_ids: movieData.genres?.map(genre => genre.id.toString()) || [],
              release_date: movieData.release_date
            }
          };
        } catch (error) {
          console.error(`Error fetching movie ${interaction.movie_id}:`, error);
          return {
            ...interaction,
            movie: {
              id: interaction.movie_id,
              title: 'Movie Not Found',
              poster_path: null,
              genre_ids: [],
              release_date: ''
            }
          };
        }
      });

      const statsData = await Promise.all(moviePromises);

      // İstatistikleri hesapla
      const stats: Stats = {
        watched: 0,
        liked: 0,
        disliked: 0,
        watchlist: 0,
        totalMovies: 0,
        averageRating: 0,
        topGenres: [],
        recentMovies: []
      };

      // Aksiyon sayılarını hesapla
      statsData.forEach((interaction) => {
        if (interaction.action) {
          stats[interaction.action as keyof Pick<Stats, 'watched' | 'liked' | 'disliked' | 'watchlist'>]++;
        }
      });

      // Toplam film sayısı
      stats.totalMovies = statsData.length;

      // Ortalama rating
      const ratingsSum = statsData.reduce((sum, interaction) => sum + (interaction.rating || 0), 0);
      stats.averageRating = stats.totalMovies > 0 ? ratingsSum / stats.totalMovies : 0;

      // Beğenilen filmler
      const likedMovies = statsData
        .filter(interaction => 
          interaction.movie && // null check
          interaction.action === 'liked' // sadece liked aksiyonları
        )
        .map(interaction => ({
          id: interaction.movie_id,
          title: interaction.movie.title,
          poster_path: interaction.movie.poster_path,
          rating: interaction.rating || 0,
          created_at: interaction.created_at,
          action: interaction.action
        }));

      stats.recentMovies = likedMovies;

      // Top genres hesapla - null kontrolü ekle
      const genreCounts: { [key: string]: number } = {};
      statsData.forEach(interaction => {
        if (interaction.movie?.genre_ids?.length) {
          interaction.movie.genre_ids.forEach(genreId => {
            const genre = movieGenres.find(g => g.id === genreId)?.name;
            if (genre) {
              genreCounts[genre] = (genreCounts[genre] || 0) + 1;
            }
          });
        }
      });

      stats.topGenres = Object.entries(genreCounts)
        .map(([genre, count]) => ({ genre, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 3);

      setStats(stats);

    } catch (error: any) {
      console.error('Error loading stats:', error);
      setError(error.message);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadStats();
    setRefreshing(false);
  };

  const loadUserData = async () => {
    try {
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      // Profil bilgilerini al
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single();

      if (profileError) throw profileError;

      // Notification ayarlarını al
      const { data: notifications, error: notificationsError } = await supabase
        .from('notification_settings')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (!notificationsError && notifications) {
        setNotificationSettings({
          newMatches: notifications.newMatches,
          newMessages: notifications.newMessages,
          movieSuggestions: notifications.movieSuggestions,
        });
      }

      // Privacy ayarlarını al
      const { data: privacy, error: privacyError } = await supabase
        .from('privacy_settings')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (!privacyError && privacy) {
        setPrivacySettings({
          profileVisible: privacy.profileVisible,
          showRatings: privacy.showRatings,
        });
      }

      setProfile(profile);
    } catch (error) {
      console.error('Error loading user data:', error);
    }
  };

  const checkPermissions = async () => {
    if (Platform.OS !== 'web') {
      const { status: mediaStatus } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      const { status: cameraStatus } = await ImagePicker.requestCameraPermissionsAsync();
      
      if (mediaStatus !== 'granted' || cameraStatus !== 'granted') {
        Alert.alert(
          'Permissions Required',
          'Please grant camera and photo library permissions to use this feature.',
          [
            { text: 'OK', onPress: () => console.log('Permission denied') },
            { 
              text: 'Open Settings', 
              onPress: () => Linking.openSettings() 
            }
          ]
        );
      }
    }
  };

  const pickImage = async () => {
    try {
      const options: ImagePicker.ImagePickerOptions = {
        mediaTypes: 'images',
        allowsEditing: true,
        aspect: [1, 1],
        quality: Platform.OS === 'ios' ? 0.8 : 0.5,
        base64: true,
      };

      Alert.alert(
        'Change Profile Photo',
        'Choose a photo source',
        [
          {
            text: 'Cancel',
            style: 'cancel'
          },
          {
            text: 'Camera',
            onPress: async () => {
              try {
                const result = await ImagePicker.launchCameraAsync(options);
                await handleImagePickerResult(result);
              } catch (error) {
                console.error('Camera error:', error);
                Alert.alert('Error', 'Failed to take photo');
              }
            }
          },
          {
            text: 'Photo Library',
            onPress: async () => {
              try {
                const result = await ImagePicker.launchImageLibraryAsync(options);
                await handleImagePickerResult(result);
              } catch (error) {
                console.error('Gallery error:', error);
                Alert.alert('Error', 'Failed to pick photo');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Error in pickImage:', error);
      Alert.alert('Error', 'Failed to open image picker');
    }
  };

  const handleImagePickerResult = async (result: ImagePicker.ImagePickerResult) => {
    try {
      if (!result.canceled && result.assets[0].base64) {
        const base64Size = result.assets[0].base64.length * 0.75;
        const maxSize = 5 * 1024 * 1024; // 5MB

        if (base64Size > maxSize) {
          Alert.alert(
            'File Too Large',
            'Please choose a smaller image (max 5MB)'
          );
          return;
        }

        await uploadAvatar(result.assets[0].base64);
      }
    } catch (error) {
      console.error('Error handling image result:', error);
      Alert.alert('Error', 'Failed to process selected image');
    }
  };

  const uploadAvatar = async (base64Image: string) => {
    try {
      setUploading(true);

      // Kullanıcı kontrolü
      if (!user?.id) {
        throw new Error('User not found');
      }

      // Dosya adını oluştur
      const fileName = `avatar-${user.id}-${Date.now()}.jpg`;
      const filePath = `avatars/${fileName}`;

      // Base64'ü ArrayBuffer'a çevir
      const arrayBuffer = decode(base64Image);

      // Önce eski avatarı sil
      if (profile?.avatar_url) {
        const oldFilePath = profile.avatar_url.split('/').pop();
        if (oldFilePath) {
          await supabase.storage
            .from('avatars')
            .remove([`avatars/${oldFilePath}`]);
        }
      }

      // Supabase Storage'a yükle
      const { error: uploadError } = await supabase.storage
        .from('avatars')
        .upload(filePath, arrayBuffer, {
          contentType: 'image/jpeg',
          upsert: true,
        });

      if (uploadError) throw uploadError;

      // Public URL al
      const { data: { publicUrl }, error: urlError } = await supabase.storage
        .from('avatars')
        .getPublicUrl(filePath);

      if (urlError) throw urlError;

      // Profili güncelle
      const { data: updatedProfile, error: updateError } = await supabase
        .from('profiles')
        .update({ 
          avatar_url: publicUrl,
          updated_at: new Date().toISOString()
        })
        .eq('id', user.id)
        .select()
        .single();

      if (updateError) throw updateError;

      // Sadece profile state'ini güncelle
      setProfile(updatedProfile);
      
      // Profil verilerini yeniden yükle
      await loadUserData();

      Alert.alert('Success', 'Profile photo updated successfully');

    } catch (error) {
      console.error('Error uploading avatar:', error);
      Alert.alert('Error', 'Failed to update profile photo');
    } finally {
      setUploading(false);
    }
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    header: {
      paddingTop: 40,
      paddingBottom: 20,
      backgroundColor: colors.surface,
      alignItems: 'center',
    },
    avatarContainer: {
      alignItems: 'center',
      marginBottom: 16,
      position: 'relative',
    },
    avatarImage: {
      width: 120,
      height: 120,
      borderRadius: 60,
      backgroundColor: colors.surface,
    },
    avatarPlaceholder: {
      width: 120,
      height: 120,
      borderRadius: 60,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: colors.primary,
    },
    avatarText: {
      color: 'white',
      fontSize: 40,
      fontWeight: 'bold',
    },
    editButton: {
      position: 'absolute',
      right: -12,
      bottom: 0,
      backgroundColor: colors.primary,
      width: 32,
      height: 32,
      borderRadius: 16,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 3,
      borderColor: colors.surface,
    },
    name: {
      fontSize: 24,
      fontWeight: 'bold',
      color: colors.text,
      marginBottom: 4,
    },
    phoneNumber: {
      fontSize: 16,
      color: colors.textSecondary,
    },
    statsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      paddingVertical: 20,
      backgroundColor: colors.surface,
      marginBottom: 20,
    },
    statItem: {
      alignItems: 'center',
    },
    statNumber: {
      color: colors.text,
      fontSize: 24,
      fontWeight: 'bold',
      marginBottom: 4,
    },
    statLabel: {
      color: colors.textSecondary,
      fontSize: 14,
    },
    statDivider: {
      width: 1,
      backgroundColor: colors.border,
    },
    section: {
      padding: 20,
    },
    sectionTitle: {
      color: colors.text,
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 16,
    },
    menuItem: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 16,
      borderBottomWidth: 1,
      borderBottomColor: colors.border,
    },
    menuItemText: {
      color: colors.text,
      fontSize: 16,
      marginLeft: 16,
      flex: 1,
    },
    signOutButton: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 20,
      paddingVertical: 16,
      backgroundColor: colors.surface,
      borderRadius: 12,
      justifyContent: 'center',
    },
    signOutButtonDisabled: {
      opacity: 0.7,
    },
    signOutButtonText: {
      color: colors.text,
      fontSize: 16,
      fontWeight: 'bold',
      marginLeft: 16,
    },
    genreGrid: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginTop: 12,
    },
    genreItem: {
      paddingHorizontal: 16,
      paddingVertical: 8,
      borderRadius: 20,
      backgroundColor: 'rgba(255, 255, 255, 0.1)',
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.2)',
    },
    genreItemSelected: {
      backgroundColor: colors.primary,
      borderColor: colors.primary,
    },
    genreText: {
      color: colors.text,
      fontSize: 14,
    },
    genreTextSelected: {
      color: '#fff',
      fontWeight: 'bold',
    },
    recentMoviesContainer: {
      gap: 12,
      paddingRight: 16,
    },
    movieCard: {
      width: 120,
      backgroundColor: '#fff',
      borderRadius: 8,
      overflow: 'hidden',
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 3.84,
    },
    moviePoster: {
      width: '100%',
      height: 180,
      resizeMode: 'cover',
    },
    movieInfo: {
      padding: 8,
    },
    movieTitle: {
      fontSize: 14,
      fontWeight: '500',
      marginBottom: 4,
      color: '#000',
    },
    ratingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    ratingText: {
      marginLeft: 4,
      fontSize: 14,
      color: '#666',
    },
    topGenresContainer: {
      gap: 12,
    },
    topGenreItem: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: colors.surface,
      borderRadius: 12,
      padding: 12,
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 3.84,
    },
    genreRankContainer: {
      width: 40,
      height: 40,
      borderRadius: 20,
      backgroundColor: colors.primary,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: 12,
    },
    genreRank: {
      color: '#fff',
      fontSize: 18,
      fontWeight: 'bold',
    },
    genreDetails: {
      flex: 1,
    },
    genreName: {
      color: colors.text,
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: 4,
    },
    genreCount: {
      color: colors.textSecondary,
      fontSize: 14,
    },
    watchDate: {
      color: colors.textSecondary,
      fontSize: 12,
    },
    settingItem: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: 16,
      borderRadius: 12,
      marginBottom: 8,
    },
    settingInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
    },
    settingText: {
      fontSize: 16,
      fontWeight: '500',
    },
    uploadingOverlay: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(255,255,255,0.8)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 60,
    },
    editBadge: {
      position: 'absolute',
      right: 0,
      bottom: 0,
      backgroundColor: colors.primary,
      width: 36,
      height: 36,
      borderRadius: 18,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 3,
      borderColor: 'white',
    },
  });

  const renderSettings = () => (
    <View style={styles.section}>
      <Text style={[styles.sectionTitle, { color: colors.text }]}>Settings</Text>
      
      <TouchableOpacity
        style={[styles.settingItem, { backgroundColor: colors.surface }]}
        onPress={() => setShowEditProfile(true)}
      >
        <View style={styles.settingInfo}>
          <MaterialCommunityIcons name="account-edit" size={24} color={colors.primary} />
          <Text style={[styles.settingText, { color: colors.text }]}>Edit Profile</Text>
        </View>
        <MaterialCommunityIcons name="chevron-right" size={24} color={colors.textSecondary} />
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.settingItem, { backgroundColor: colors.surface }]}
        onPress={() => setShowNotifications(true)}
      >
        <View style={styles.settingInfo}>
          <MaterialCommunityIcons name="bell-outline" size={24} color={colors.primary} />
          <Text style={[styles.settingText, { color: colors.text }]}>Notifications</Text>
        </View>
        <MaterialCommunityIcons name="chevron-right" size={24} color={colors.textSecondary} />
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.settingItem, { backgroundColor: colors.surface }]}
        onPress={() => setShowPrivacy(true)}
      >
        <View style={styles.settingInfo}>
          <MaterialCommunityIcons name="shield-outline" size={24} color={colors.primary} />
          <Text style={[styles.settingText, { color: colors.text }]}>Privacy</Text>
        </View>
        <MaterialCommunityIcons name="chevron-right" size={24} color={colors.textSecondary} />
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.settingItem, { backgroundColor: colors.surface }]}
        onPress={handleSignOut}
      >
        <View style={styles.settingInfo}>
          <MaterialCommunityIcons name="logout" size={24} color={colors.error} />
          <Text style={[styles.settingText, { color: colors.error }]}>Sign Out</Text>
        </View>
      </TouchableOpacity>
    </View>
  );

  // Okunmamış bildirim sayısı
  const unreadCount = notifications.filter(n => !n.read).length;

  return (
    <ScrollView 
      style={styles.container}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
      }
    >
      <View style={styles.header}>
        <View style={styles.avatarContainer}>
          <TouchableOpacity 
            style={styles.avatarContainer} 
            onPress={pickImage}
            disabled={uploading}
          >
            {profile?.avatar_url ? (
              <Image
                source={{ uri: profile.avatar_url }}
                style={styles.avatarImage}
                resizeMode="cover"
              />
            ) : (
              <View style={[styles.avatarPlaceholder, { backgroundColor: colors.primary }]}>
                <Text style={styles.avatarText}>
                  {profile?.first_name?.substring(0, 2).toUpperCase() || 'UP'}
                </Text>
              </View>
            )}
            {uploading ? (
              <View style={styles.uploadingOverlay}>
                <ActivityIndicator color={colors.primary} />
              </View>
            ) : (
              <View style={styles.editBadge}>
                <MaterialCommunityIcons name="camera" size={20} color="white" />
              </View>
            )}
          </TouchableOpacity>
        </View>
        <Text style={styles.name}>{profile?.first_name || 'User'}</Text>
        <Text style={styles.phoneNumber}>{profile?.phone || 'No phone number'}</Text>
      </View>

      <View style={styles.statsContainer}>
        <View style={styles.statItem}>
          <Text style={styles.statNumber}>{stats?.liked || 0}</Text>
          <Text style={styles.statLabel}>Films Liked</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statNumber}>{stats?.averageRating.toFixed(1) || '0.0'}</Text>
          <Text style={styles.statLabel}>Average Rating</Text>
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Liked Movies</Text>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.recentMoviesContainer}
        >
          {stats?.recentMovies.map((movie, index) => (
            <TouchableOpacity
              key={`${movie.id}-${index}`}
              style={styles.movieCard}
              onPress={() => router.push({
                pathname: '/movie/[id]',
                params: { id: movie.id }
              })}
            >
              <Image
                source={{ 
                  uri: movie.poster_path 
                    ? `https://image.tmdb.org/t/p/w500${movie.poster_path}`
                    : 'https://via.placeholder.com/500x750'
                }}
                style={styles.moviePoster}
              />
              <View style={styles.movieInfo}>
                <Text style={styles.movieTitle} numberOfLines={1}>
                  {movie.title || 'Movie Not Found'}
                </Text>
                <View style={styles.ratingContainer}>
                  <MaterialCommunityIcons name="star" size={16} color="#FFD700" />
                  <Text style={styles.ratingText}>{movie.rating.toFixed(1)}</Text>
                </View>
                <Text style={styles.watchDate}>
                  {new Date(movie.created_at).toLocaleDateString()}
                </Text>
              </View>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Favorite Movie Genres</Text>
        <View style={styles.genreGrid}>
          {movieGenres.map(genre => (
            <TouchableOpacity
              key={genre.id}
              style={[
                styles.genreItem,
                selectedGenres.includes(genre.id) && styles.genreItemSelected
              ]}
              onPress={() => toggleGenre(genre.id)}
              disabled={loadingGenres}
            >
              <Text style={[
                styles.genreText,
                selectedGenres.includes(genre.id) && styles.genreTextSelected
              ]}>
                {genre.name}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {renderSettings()}

      <EditProfileModal
        visible={showEditProfile}
        onClose={() => setShowEditProfile(false)}
        currentUser={{
          first_name: profile?.first_name || '',
          bio: profile?.bio,
        }}
        onUpdate={loadUserData}
      />

      <NotificationsModal
        visible={showNotifications}
        onClose={() => setShowNotifications(false)}
        settings={notificationSettings}
        onUpdate={() => {
          loadUserData();
          // Notification ayarlarını yeniden yükle
        }}
      />

      <PrivacyModal
        visible={showPrivacy}
        onClose={() => setShowPrivacy(false)}
        settings={privacySettings}
        onUpdate={() => {
          loadUserData();
          // Privacy ayarlarını yeniden yükle
        }}
      />
    </ScrollView>
  );
}

================
File: app/(tabs)/watched.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Dimensions,
  Image,
  SafeAreaView,
  TextInput,
} from 'react-native';
import { useAuth } from '../../contexts/auth';
import { useTheme } from '../../contexts/theme';
import { supabase } from '../../lib/supabase';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { TMDB_IMAGE_URL } from '../../lib/tmdb';
import { movieGenres } from '../../lib/tmdb/genres';

const { width } = Dimensions.get('window');
const COLUMN_WIDTH = (width - 48) / 2;

interface MovieInteraction {
  movie_id: number;
  title: string;
  poster_path: string | null;
  rating: number;
  action: 'liked' | 'watchlist';
  created_at: string;
  vote_average?: number;
  genres?: string[];
}

interface Filters {
  search: string;
  minRating: number;
  selectedGenres: string[];
  minImdbRating: number;
}

export default function LibraryScreen() {
  const [movies, setMovies] = useState<MovieInteraction[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState<'liked' | 'watchlist'>('liked');
  const [showFilters, setShowFilters] = useState(false);
  const [filters, setFilters] = useState<Filters>({
    search: '',
    minRating: 0,
    selectedGenres: [],
    minImdbRating: 0,
  });
  const { user } = useAuth();
  const { colors } = useTheme();

  useEffect(() => {
    loadMovies();
  }, [activeTab]);

  const loadMovies = async () => {
    try {
      setLoading(true);
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      // Seçili tab'a göre filmleri al
      const { data: interactions, error: interactionsError } = await supabase
        .from('movie_interactions')
        .select('*')
        .eq('user_id', user.id)
        .eq('action', activeTab)
        .order('created_at', { ascending: false });

      if (interactionsError) throw interactionsError;

      // Film detaylarını TMDB'den al
      const moviePromises = interactions.map(async (interaction) => {
        try {
          const response = await fetch(
            `https://api.themoviedb.org/3/movie/${interaction.movie_id}`,
            {
              headers: {
                'Authorization': `Bearer ${process.env.EXPO_PUBLIC_TMDB_ACCESS_TOKEN}`,
                'Content-Type': 'application/json'
              }
            }
          );

          if (!response.ok) throw new Error('TMDB API error');
          const movieData = await response.json();

          return {
            movie_id: interaction.movie_id,
            title: movieData.title,
            poster_path: movieData.poster_path,
            rating: interaction.rating || 0,
            action: interaction.action,
            created_at: interaction.created_at,
            vote_average: movieData.vote_average,
            genres: movieData.genres.map(g => g.name)
          };
        } catch (error) {
          console.error('Error fetching movie:', error);
          return null;
        }
      });

      let moviesData = (await Promise.all(moviePromises)).filter((m): m is MovieInteraction => m !== null);

      // Varsayılan olarak tarihe göre sırala
      moviesData = moviesData.sort((a, b) => 
        new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      );

      setMovies(moviesData);
    } catch (error) {
      console.error('Error loading movies:', error);
    } finally {
      setLoading(false);
    }
  };

  // Filtreleme fonksiyonu
  const filterMovies = (movies: MovieInteraction[]) => {
    return movies.filter(movie => {
      // Başlık araması
      if (filters.search && !movie.title.toLowerCase().includes(filters.search.toLowerCase())) {
        return false;
      }

      // Minimum kullanıcı puanı
      if (filters.minRating > 0 && movie.rating < filters.minRating) {
        return false;
      }

      // Minimum IMDB puanı
      if (filters.minImdbRating > 0 && (movie.vote_average || 0) < filters.minImdbRating) {
        return false;
      }

      // Seçili türler
      if (filters.selectedGenres.length > 0 && 
          !movie.genres?.some(genre => filters.selectedGenres.includes(genre))) {
        return false;
      }

      return true;
    });
  };

  const renderMovie = ({ item }: { item: MovieInteraction }) => (
    <TouchableOpacity
      style={[styles.movieCard, { backgroundColor: colors.surface }]}
      onPress={() => router.push({
        pathname: '/movie/[id]',
        params: { id: item.movie_id }
      })}
    >
      <Image
        source={{
          uri: item.poster_path
            ? `${TMDB_IMAGE_URL}/w500${item.poster_path}`
            : 'https://via.placeholder.com/500x750'
        }}
        style={styles.poster}
      />
      <View style={styles.movieInfo}>
        <Text style={[styles.title, { color: colors.text }]} numberOfLines={2}>
          {item.title}
        </Text>
        <View style={styles.ratingContainer}>
          <MaterialCommunityIcons name="star" size={16} color="#FFD700" />
          <Text style={[styles.rating, { color: colors.textSecondary }]}>
            {item.rating.toFixed(1)}
          </Text>
          <Text style={[styles.date, { color: colors.textSecondary }]}>
            {new Date(item.created_at).toLocaleDateString()}
          </Text>
        </View>
        <View style={[styles.badge, { backgroundColor: colors.primary + '20' }]}>
          <Text style={[styles.badgeText, { color: colors.primary }]}>
            {item.action.toUpperCase()}
          </Text>
        </View>
      </View>
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <View style={styles.content}>
        <View style={styles.header}>
          <View style={styles.tabContainer}>
            <TouchableOpacity
              style={[
                styles.tab,
                activeTab === 'liked' && { backgroundColor: colors.primary }
              ]}
              onPress={() => setActiveTab('liked')}
            >
              <MaterialCommunityIcons
                name="heart"
                size={20}
                color={activeTab === 'liked' ? '#fff' : colors.textSecondary}
              />
              <Text style={[
                styles.tabText,
                activeTab === 'liked' && { color: '#fff' }
              ]}>
                Liked
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.tab,
                activeTab === 'watchlist' && { backgroundColor: colors.primary }
              ]}
              onPress={() => setActiveTab('watchlist')}
            >
              <MaterialCommunityIcons
                name="bookmark"
                size={20}
                color={activeTab === 'watchlist' ? '#fff' : colors.textSecondary}
              />
              <Text style={[
                styles.tabText,
                activeTab === 'watchlist' && { color: '#fff' }
              ]}>
                Watchlist
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.searchContainer}>
          <View style={styles.searchInputContainer}>
            <MaterialCommunityIcons name="magnify" size={20} color={colors.textSecondary} />
            <TextInput
              style={[styles.searchInput, { color: colors.text }]}
              placeholder="Search movies..."
              placeholderTextColor={colors.textSecondary}
              value={filters.search}
              onChangeText={(text) => setFilters(prev => ({ ...prev, search: text }))}
            />
          </View>
          <TouchableOpacity
            style={[
              styles.filterButton,
              showFilters && { backgroundColor: colors.primary }
            ]}
            onPress={() => setShowFilters(!showFilters)}
          >
            <MaterialCommunityIcons
              name="filter-variant"
              size={20}
              color={showFilters ? '#fff' : colors.textSecondary}
            />
          </TouchableOpacity>
        </View>

        {showFilters && (
          <View style={styles.filtersContainer}>
            <Text style={[styles.filterTitle, { color: colors.text }]}>Filters</Text>
            
            <View style={styles.filterSection}>
              <Text style={[styles.filterLabel, { color: colors.textSecondary }]}>
                Minimum Rating
              </Text>
              <View style={styles.ratingButtons}>
                {[0, 3, 4, 5].map(rating => (
                  <TouchableOpacity
                    key={rating}
                    style={[
                      styles.ratingButton,
                      filters.minRating === rating && { backgroundColor: colors.primary }
                    ]}
                    onPress={() => setFilters(prev => ({ ...prev, minRating: rating }))}
                  >
                    <Text style={[
                      styles.ratingButtonText,
                      filters.minRating === rating && { color: '#fff' }
                    ]}>
                      {rating === 0 ? 'All' : `${rating}+`}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <View style={styles.filterSection}>
              <Text style={[styles.filterLabel, { color: colors.textSecondary }]}>
                Minimum IMDB Rating
              </Text>
              <View style={styles.ratingButtons}>
                {[0, 6, 7, 8].map(rating => (
                  <TouchableOpacity
                    key={rating}
                    style={[
                      styles.ratingButton,
                      filters.minImdbRating === rating && { backgroundColor: colors.primary }
                    ]}
                    onPress={() => setFilters(prev => ({ ...prev, minImdbRating: rating }))}
                  >
                    <Text style={[
                      styles.ratingButtonText,
                      filters.minImdbRating === rating && { color: '#fff' }
                    ]}>
                      {rating === 0 ? 'All' : `${rating}+`}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <View style={styles.filterSection}>
              <Text style={[styles.filterLabel, { color: colors.textSecondary }]}>
                Genres
              </Text>
              <View style={styles.genreGrid}>
                {movieGenres.map(genre => (
                  <TouchableOpacity
                    key={genre.id}
                    style={[
                      styles.genreButton,
                      filters.selectedGenres.includes(genre.name) && { backgroundColor: colors.primary }
                    ]}
                    onPress={() => {
                      setFilters(prev => ({
                        ...prev,
                        selectedGenres: prev.selectedGenres.includes(genre.name)
                          ? prev.selectedGenres.filter(g => g !== genre.name)
                          : [...prev.selectedGenres, genre.name]
                      }));
                    }}
                  >
                    <Text style={[
                      styles.genreButtonText,
                      filters.selectedGenres.includes(genre.name) && { color: '#fff' }
                    ]}>
                      {genre.name}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
          </View>
        )}

        {loading ? (
          <ActivityIndicator size="large" color={colors.primary} />
        ) : movies.length === 0 ? (
          <View style={styles.emptyContainer}>
            <MaterialCommunityIcons
              name="movie-off"
              size={64}
              color={colors.textSecondary}
            />
            <Text style={[styles.emptyText, { color: colors.text }]}>
              No movies found
            </Text>
          </View>
        ) : (
          <FlatList
            data={filterMovies(movies)}
            renderItem={renderMovie}
            keyExtractor={(item) => `${item.movie_id}-${item.action}`}
            numColumns={2}
            contentContainerStyle={styles.list}
            columnWrapperStyle={styles.columnWrapper}
          />
        )}
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  header: {
    padding: 16,
    paddingTop: 8,
    paddingBottom: 8,
  },
  tabContainer: {
    flexDirection: 'row',
    gap: 12,
  },
  tab: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    paddingHorizontal: 24,
    borderRadius: 100,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    gap: 8,
    flex: 1,
    justifyContent: 'center',
  },
  tabText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ccc',
  },
  list: {
    padding: 16,
  },
  columnWrapper: {
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  movieCard: {
    width: COLUMN_WIDTH,
    borderRadius: 12,
    overflow: 'hidden',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
  },
  poster: {
    width: '100%',
    aspectRatio: 2/3,
    resizeMode: 'cover',
  },
  movieInfo: {
    padding: 12,
  },
  title: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 4,
  },
  rating: {
    fontSize: 12,
    marginRight: 8,
  },
  date: {
    fontSize: 12,
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    alignSelf: 'flex-start',
  },
  badgeText: {
    fontSize: 10,
    fontWeight: 'bold',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    gap: 16,
  },
  emptyText: {
    fontSize: 16,
    textAlign: 'center',
  },
  searchContainer: {
    flexDirection: 'row',
    padding: 16,
    paddingTop: 8,
    gap: 12,
  },
  searchInputContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 100,
    paddingHorizontal: 16,
    gap: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  filterButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  filtersContainer: {
    padding: 16,
    paddingTop: 0,
  },
  filterTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  filterSection: {
    marginBottom: 16,
  },
  filterLabel: {
    fontSize: 14,
    marginBottom: 8,
  },
  ratingButtons: {
    flexDirection: 'row',
    gap: 8,
  },
  ratingButton: {
    flex: 1,
    padding: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    alignItems: 'center',
  },
  ratingButtonText: {
    fontSize: 14,
    color: '#ccc',
  },
  genreGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  genreButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 100,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  genreButtonText: {
    fontSize: 14,
    color: '#ccc',
  },
});

================
File: app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet, Text, View } from 'react-native';
import { useTheme } from '../contexts/theme';

export default function NotFoundScreen() {
  const { colors } = useTheme();

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
      backgroundColor: colors.background,
    },
    text: {
      fontSize: 20,
      fontWeight: 'bold',
      color: colors.text,
    },
    link: {
      marginTop: 15,
      paddingVertical: 15,
      color: colors.primary,
    },
  });

  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <View style={styles.container}>
        <Text style={styles.text}>This screen doesn't exist.</Text>
        <Link href="/" style={styles.link}>
          <Text style={styles.link}>Go to home screen!</Text>
        </Link>
      </View>
    </>
  );
}

================
File: app/index.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Image,
  Animated,
  Dimensions,
  Easing,
} from 'react-native';
import { router, Redirect } from 'expo-router';
import { signInWithEmail } from '../lib/auth';
import { useAuth } from '../contexts/auth';
import { TMDB_IMAGE_URL } from '../lib/tmdb';

const { width, height } = Dimensions.get('window');
const POSTER_SIZE = width / 3; // 3 afiş yan yana
const POSTER_HEIGHT = POSTER_SIZE * 1.5;
const DURATION = 40000; // Her satırın hareket süresi (ms)
const ROWS = Math.ceil(height / POSTER_HEIGHT) + 1; // Ekranı kaplamak için gereken satır sayısı
const POSTERS_PER_ROW = Math.ceil(width / POSTER_SIZE) + 4; // Ekstra poster ekledik

interface MoviePoster {
  id: number;
  poster_path: string;
}

export default function EmailAuthScreen() {
  const { user, isLoading } = useAuth();
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [posters, setPosters] = useState<MoviePoster[]>([]);
  const rowAnimations = [...Array(ROWS)].map(() => new Animated.Value(0));

  const handleSignIn = async () => {
    try {
      setLoading(true);
      setError(null);
      
      if (!email) {
        throw new Error('Please enter your email');
      }

      const response = await signInWithEmail(email);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to sign in');
      }

      // Başarılı giriş sonrası onboarding'e yönlendir
      router.replace('/(auth)/onboarding');

    } catch (err: any) {
      console.error('Error signing in:', err);
      setError(err.message || 'Failed to sign in');
    } finally {
      setLoading(false);
    }
  };

  // Film posterlerini yükle
  useEffect(() => {
    const loadMoviePosters = async () => {
      try {
        const response = await fetch(
          'https://api.themoviedb.org/3/movie/popular?language=en-US&page=1',
          {
            headers: {
              'Authorization': `Bearer ${process.env.EXPO_PUBLIC_TMDB_ACCESS_TOKEN}`,
              'Content-Type': 'application/json'
            }
          }
        );
        const data = await response.json();
        const validPosters = data.results
          .filter((movie: any) => movie.poster_path)
          .map((movie: any) => ({
            id: movie.id,
            poster_path: movie.poster_path
          }));
        setPosters(validPosters);
      } catch (error) {
        console.error('Error loading movie posters:', error);
      }
    };

    loadMoviePosters();
  }, []);

  // Animasyonları başlat
  useEffect(() => {
    if (posters.length === 0) return;

    // Her satır için sonsuz animasyon
    rowAnimations.forEach((anim, index) => {
      const isEven = index % 2 === 0;
      const startPosition = isEven ? 0 : -POSTER_SIZE * POSTERS_PER_ROW;
      const endPosition = isEven ? -POSTER_SIZE * POSTERS_PER_ROW : 0;

      anim.setValue(startPosition);

      Animated.loop(
        Animated.timing(anim, {
          toValue: endPosition,
          duration: DURATION,
          easing: Easing.linear,
          useNativeDriver: true,
        })
      ).start();
    });

    return () => {
      rowAnimations.forEach(anim => anim.stopAnimation());
    };
  }, [posters]);

  const renderPosterRow = (rowIndex: number) => {
    const isEven = rowIndex % 2 === 0;
    const startIndex = (rowIndex * POSTERS_PER_ROW) % posters.length;
    const rowPosters = [
      ...posters.slice(startIndex),
      ...posters.slice(0, startIndex),
      ...posters.slice(startIndex),
      ...posters.slice(0, POSTERS_PER_ROW * 2), // Daha fazla ekstra poster
    ];

    return (
      <Animated.View
        key={rowIndex}
        style={[
          styles.posterRow,
          {
            transform: [{ translateX: rowAnimations[rowIndex] }],
          }
        ]}
      >
        {rowPosters.map((movie, index) => (
          <Image
            key={`${movie.id}-${index}`}
            source={{ uri: `${TMDB_IMAGE_URL}/w342${movie.poster_path}` }}
            style={styles.posterImage}
            blurRadius={Platform.OS === 'ios' ? 4 : 5}
          />
        ))}
      </Animated.View>
    );
  };

  // Yükleme durumu
  if (isLoading) {
    return (
      <View style={styles.container}>
        <View style={styles.backgroundContainer}>
          {[...Array(ROWS)].map((_, index) => renderPosterRow(index))}
        </View>
        <View style={styles.overlay} />
      </View>
    );
  }

  // Yönlendirme
  if (!user) {
    return (
      <View style={styles.container}>
        <View style={styles.backgroundContainer}>
          {[...Array(ROWS)].map((_, index) => renderPosterRow(index))}
        </View>
        <View style={styles.overlay} />
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.content}
        >
          <View style={styles.formContainer}>
            <View style={styles.logoContainer}>
              <Text style={styles.title}>MovieMate</Text>
              <Text style={styles.subtitle}>Find your perfect movie match</Text>
            </View>
            
            {error && (
              <View style={styles.errorContainer}>
                <Text style={styles.errorText}>{error}</Text>
              </View>
            )}

            <TextInput
              style={styles.input}
              placeholder="Email address"
              placeholderTextColor="#999"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              editable={!loading}
            />
            <TouchableOpacity
              style={[styles.button, loading && styles.buttonDisabled]}
              onPress={handleSignIn}
              disabled={loading || !email.trim()}
            >
              {loading ? (
                <ActivityIndicator color="#fff" />
              ) : (
                <Text style={styles.buttonText}>Continue with Email</Text>
              )}
            </TouchableOpacity>
          </View>
        </KeyboardAvoidingView>
      </View>
    );
  }

  return <Redirect href="/(tabs)" />;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  backgroundContainer: {
    ...StyleSheet.absoluteFillObject,
    overflow: 'hidden',
  },
  posterRow: {
    flexDirection: 'row',
    height: POSTER_HEIGHT,
    marginLeft: -2, // Posterler arası boşluğu kapat
  },
  posterImage: {
    width: POSTER_SIZE,
    height: POSTER_HEIGHT,
    marginHorizontal: 1, // Minimal boşluk
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0,0,0,0.6)', // 0.75'ten 0.6'ya düşürdük
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
    paddingTop: 60,
  },
  formContainer: {
    width: '100%',
    maxWidth: 400,
    alignSelf: 'center',
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 10,
  },
  title: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 12,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 18,
    color: '#ccc',
    textAlign: 'center',
    marginBottom: 40,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 0, 0, 0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 15,
  },
  errorText: {
    color: '#ff6b6b',
    textAlign: 'center',
    fontSize: 14,
  },
  input: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    color: '#fff',
    fontSize: 16,
  },
  button: {
    backgroundColor: '#e50914',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
    marginBottom: 15,
  },
  buttonDisabled: {
    opacity: 0.7,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/matches/[id].tsx
================
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  SafeAreaView,
  Image,
  ActivityIndicator,
  Animated,
} from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { useAuth } from '../../contexts/auth';
import { useTheme } from '../../contexts/theme';
import { supabase } from '../../lib/supabase';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { format } from 'date-fns';

interface Message {
  id: string;
  content: string;
  created_at: string;
  sender_id: string;
  match_id: string;
}

interface ChatUser {
  id: string;
  first_name: string;
  avatar_url: string | null;
}

export default function ChatModal() {
  const { id } = useLocalSearchParams();
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [chatUser, setChatUser] = useState<ChatUser | null>(null);
  const [isSending, setIsSending] = useState(false);
  const { user } = useAuth();
  const { colors } = useTheme();
  const flatListRef = useRef<FlatList>(null);
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    loadChatData();
    setupRealtimeSubscription();
  }, [id]);

  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  }, []);

  const loadChatData = async () => {
    try {
      setIsLoading(true);
      await Promise.all([loadMessages(), loadChatUser()]);
    } catch (error) {
      console.error('Error loading chat data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadChatUser = async () => {
    try {
      const { data: matchData, error: matchError } = await supabase
        .from('matches')
        .select('user1_id, user2_id')
        .eq('id', id)
        .single();

      if (matchError) throw matchError;

      const otherUserId = matchData.user1_id === user?.id ? matchData.user2_id : matchData.user1_id;

      const { data: userData, error: userError } = await supabase
        .from('profiles')
        .select('id, first_name, avatar_url')
        .eq('id', otherUserId)
        .single();

      if (userError) throw userError;
      setChatUser(userData);
    } catch (error) {
      console.error('Error loading chat user:', error);
    }
  };

  const setupRealtimeSubscription = () => {
    const subscription = supabase
      .channel('messages')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'messages',
        filter: `match_id=eq.${id}`,
      }, (payload) => {
        const newMessage = payload.new as Message;
        setMessages(prev => [...prev, newMessage]);
        scrollToBottom();
      })
      .subscribe();

    return () => subscription.unsubscribe();
  };

  const loadMessages = async () => {
    try {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .eq('match_id', id)
        .order('created_at', { ascending: true });

      if (error) throw error;
      setMessages(data || []);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!newMessage.trim() || !user || isSending) return;

    try {
      setIsSending(true);
      const { error } = await supabase
        .from('messages')
        .insert({
          match_id: id,
          sender_id: user.id,
          content: newMessage.trim(),
        });

      if (error) throw error;
      setNewMessage('');
      scrollToBottom();
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsSending(false);
    }
  };

  const scrollToBottom = () => {
    if (flatListRef.current && messages.length > 0) {
      flatListRef.current.scrollToEnd({ animated: true });
    }
  };

  const renderMessage = ({ item }: { item: Message }) => {
    const isMyMessage = item.sender_id === user?.id;
    const messageDate = new Date(item.created_at);

    return (
      <Animated.View 
        style={[
          styles.messageContainer,
          isMyMessage ? styles.myMessage : styles.theirMessage,
          { opacity: fadeAnim }
        ]}
      >
        {!isMyMessage && chatUser?.avatar_url && (
          <Image
            source={{ uri: chatUser.avatar_url }}
            style={styles.avatar}
          />
        )}
        <View style={[
          styles.messageBubble,
          isMyMessage ? [styles.myMessageBubble, { backgroundColor: colors.primary }] : [styles.theirMessageBubble, { backgroundColor: colors.surface }]
        ]}>
          <Text style={[
            styles.messageText,
            { color: isMyMessage ? '#fff' : colors.text }
          ]}>
            {item.content}
          </Text>
          <Text style={[
            styles.messageTime,
            { color: isMyMessage ? 'rgba(255,255,255,0.7)' : colors.textSecondary }
          ]}>
            {format(messageDate, 'HH:mm')}
          </Text>
        </View>
      </Animated.View>
    );
  };

  if (isLoading) {
    return (
      <View style={[styles.loadingContainer, { backgroundColor: colors.background }]}>
        <ActivityIndicator size="large" color={colors.primary} />
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 105 : 0}
      >
        <FlatList
          ref={flatListRef}
          data={messages}
          renderItem={renderMessage}
          keyExtractor={(item) => item.id}
          contentContainerStyle={[
            styles.messagesList,
            messages.length === 0 && { flex: 1 }
          ]}
          onContentSizeChange={scrollToBottom}
          onLayout={scrollToBottom}
          keyboardDismissMode="on-drag"
          keyboardShouldPersistTaps="handled"
        />
        <View style={[
          styles.inputContainer, 
          { 
            backgroundColor: colors.surface,
            paddingBottom: Platform.OS === 'ios' ? 30 : 8 
          }
        ]}>
          <TextInput
            style={[styles.input, { color: colors.text, backgroundColor: colors.background }]}
            value={newMessage}
            onChangeText={setNewMessage}
            placeholder="Type a message..."
            placeholderTextColor={colors.textSecondary}
            multiline
            maxLength={500}
            onSubmitEditing={sendMessage}
            keyboardType="default"
            returnKeyType="send"
            enablesReturnKeyAutomatically={true}
          />
          <TouchableOpacity
            style={[
              styles.sendButton,
              { backgroundColor: newMessage.trim() ? colors.primary : colors.textSecondary }
            ]}
            onPress={sendMessage}
            disabled={!newMessage.trim() || isSending}
          >
            {isSending ? (
              <ActivityIndicator size="small" color="#fff" />
            ) : (
              <MaterialCommunityIcons name="send" size={24} color="#fff" />
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  messagesList: {
    padding: 16,
    paddingBottom: 32,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    marginBottom: 16,
  },
  myMessage: {
    justifyContent: 'flex-end',
  },
  theirMessage: {
    justifyContent: 'flex-start',
  },
  messageBubble: {
    maxWidth: '75%',
    padding: 12,
    borderRadius: 20,
    marginHorizontal: 8,
  },
  myMessageBubble: {
    borderBottomRightRadius: 4,
  },
  theirMessageBubble: {
    borderBottomLeftRadius: 4,
  },
  messageText: {
    fontSize: 16,
    lineHeight: 20,
  },
  messageTime: {
    fontSize: 12,
    marginTop: 4,
    alignSelf: 'flex-end',
  },
  avatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 8,
    alignItems: 'flex-end',
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.1)',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 5,
  },
  input: {
    flex: 1,
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginRight: 8,
    fontSize: 16,
    maxHeight: 100,
    minHeight: 40,
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.1)',
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: app/movie/[id].tsx
================
import React, { useEffect, useState } from 'react';
import { View, Text, Image, StyleSheet, ScrollView, ActivityIndicator } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { MovieDetails, getMovieDetails, TMDB_IMAGE_URL } from '../../lib/tmdb';
import { useTheme } from '../../contexts/theme';
import { Rating } from '../../components/Rating';

export default function MovieDetailScreen() {
  const params = useLocalSearchParams();
  const id = typeof params.id === 'string' ? parseInt(params.id, 10) : params.id;
  const [movie, setMovie] = useState<MovieDetails | null>(null);
  const [loading, setLoading] = useState(true);
  const { colors } = useTheme();

  useEffect(() => {
    loadMovieDetails();
  }, [id]);

  const loadMovieDetails = async () => {
    try {
      setLoading(true);
      if (!id) {
        throw new Error('Invalid movie ID');
      }
      const details = await getMovieDetails(id);
      setMovie(details);
    } catch (error) {
      console.error('Error loading movie details:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <View style={[styles.container, styles.loading]}>
        <ActivityIndicator size="large" color={colors.primary} />
      </View>
    );
  }

  if (!movie) {
    return (
      <View style={[styles.container, styles.center]}>
        <Text style={[styles.errorText, { color: colors.text }]}>
          Failed to load movie details
        </Text>
      </View>
    );
  }

  return (
    <ScrollView 
      style={[styles.container, { backgroundColor: colors.background }]}
      contentContainerStyle={styles.content}
    >
      <Image
        source={{ 
          uri: movie.backdrop_path 
            ? `${TMDB_IMAGE_URL}/original${movie.backdrop_path}`
            : 'https://via.placeholder.com/1920x1080'
        }}
        style={styles.backdrop}
      />
      <View style={styles.detailsContainer}>
        <Text style={[styles.title, { color: colors.text }]}>
          {movie.title}
        </Text>
        <Text style={[styles.overview, { color: colors.textSecondary }]}>
          {movie.overview}
        </Text>
        <View style={styles.infoRow}>
          <Text style={[styles.infoText, { color: colors.textSecondary }]}>
            {new Date(movie.release_date).getFullYear()}
          </Text>
          <Text style={[styles.infoText, { color: colors.textSecondary }]}>
            {movie.runtime} min
          </Text>
          <Text style={[styles.infoText, { color: colors.textSecondary }]}>
            Rating: {movie.vote_average.toFixed(1)}
          </Text>
        </View>
        <View style={styles.genreContainer}>
          {movie.genres.map(genre => (
            <View 
              key={genre.id} 
              style={[styles.genreTag, { backgroundColor: colors.primary + '20' }]}
            >
              <Text style={[styles.genreText, { color: colors.primary }]}>
                {genre.name}
              </Text>
            </View>
          ))}
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flexGrow: 1,
  },
  loading: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  backdrop: {
    width: '100%',
    height: 250,
    resizeMode: 'cover',
  },
  detailsContainer: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  overview: {
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 16,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  infoText: {
    fontSize: 14,
  },
  genreContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  genreTag: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  genreText: {
    fontSize: 14,
    fontWeight: '500',
  },
  errorText: {
    fontSize: 16,
    textAlign: 'center',
  },
});

================
File: app/movies/_layout.tsx
================
import { Stack } from 'expo-router';
import { createSharedElementStackNavigator } from 'react-navigation-shared-element';
import MovieDetailScreen from './[id]';

// Tip tanımlamaları
interface RouteParams {
  id: string;
}

const SharedStack = createSharedElementStackNavigator();

export default function MoviesLayout() {
  return (
    <SharedStack.Navigator
      screenOptions={{
        headerShown: false,
        presentation: 'modal',
      }}
    >
      <SharedStack.Screen
        name="[id]"
        component={MovieDetailScreen}
        options={{
          gestureEnabled: false,
          cardStyleInterpolator: ({ current: { progress } }: { 
            current: { progress: number } 
          }) => {
            return {
              cardStyle: {
                opacity: progress,
              },
            };
          },
          sharedElements: (route: { params: RouteParams }) => {
            const { id } = route.params;
            return [
              {
                id: `movie.${id}.poster`,
                animation: 'move',
                resize: 'clip',
                align: 'center-top',
              },
              {
                id: `movie.${id}.title`,
                animation: 'fade',
                resize: 'clip',
                align: 'left-center',
              },
            ];
          },
        }}
      />
    </SharedStack.Navigator>
  );
}

================
File: app/movies/[id].tsx
================
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  Image,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
  SafeAreaView,
  Animated,
  Dimensions,
} from 'react-native';
import { useLocalSearchParams, router } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { supabase } from '../../lib/supabase';
import { Rating } from '../../components/Rating';
import { useAuth } from '../../contexts/auth';
import { SharedElement } from 'react-navigation-shared-element';

const { width } = Dimensions.get('window');
const POSTER_ASPECT_RATIO = 27 / 40;
const POSTER_WIDTH = width * 0.6;
const POSTER_HEIGHT = POSTER_WIDTH * (1 / POSTER_ASPECT_RATIO);

interface MovieDetails {
  id: string;  // UUID tipinde
  tmdb_id: number;  // TMDB'den gelen numerik ID
  title: string;
  overview: string;
  poster_path: string;
  backdrop_path: string;
  release_date: string;
  vote_average: number;
}

export default function MovieDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const { user } = useAuth();
  const [movie, setMovie] = useState<MovieDetails | null>(null);
  const [userRating, setUserRating] = useState<number>(0);
  const [loading, setLoading] = useState(true);
  const [isAnimating, setIsAnimating] = useState(false);

  useEffect(() => {
    loadMovieDetails();
    loadUserRating();
  }, [id]);

  const loadMovieDetails = async () => {
    try {
      const { data: movieData, error } = await supabase
        .from('movies')
        .select(`
          id,
          tmdb_id,
          title,
          overview,
          poster_path,
          backdrop_path,
          release_date,
          vote_average
        `)
        .eq('tmdb_id', Number(id))
        .single();

      if (error) throw error;
      setMovie(movieData);
    } catch (error) {
      console.error('Error loading movie details:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadUserRating = async () => {
    try {
      const { data, error } = await supabase
        .from('user_ratings')
        .select('rating')
        .eq('user_id', user!.id)
        .eq('movie_id', movie?.id)
        .single();

      if (error) {
        if (error.code !== 'PGRST116') throw error;
      } else {
        setUserRating(data.rating);
      }
    } catch (error) {
      console.error('Error loading user rating:', error);
    }
  };

  const handleRate = async (rating: number) => {
    try {
      const { error } = await supabase
        .from('user_ratings')
        .upsert({
          user_id: user!.id,
          movie_id: movie?.id,
          rating
        }, {
          onConflict: 'user_id,movie_id'
        });

      if (error) throw error;
      setUserRating(rating);
    } catch (error) {
      console.error('Error rating movie:', error);
    }
  };

  if (loading || !movie) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton} 
          onPress={() => router.back()}
        >
          <MaterialCommunityIcons name="arrow-left" size={24} color="#000" />
        </TouchableOpacity>
      </View>

      <View style={styles.content}>
        <SharedElement id={`movie.${movie.id}.poster`}>
          <Animated.Image
            source={{ uri: `https://image.tmdb.org/t/p/w500${movie.poster_path}` }}
            style={[styles.poster]}
            resizeMode="cover"
          />
        </SharedElement>

        <View style={styles.info}>
          <SharedElement id={`movie.${movie.id}.title`}>
            <Text style={styles.title}>{movie.title}</Text>
          </SharedElement>

          <View style={styles.metadata}>
            <Text style={styles.year}>
              {new Date(movie.release_date).getFullYear()}
            </Text>
            <Text style={styles.dot}>•</Text>
            <Text style={styles.rating}>
              IMDb {movie.vote_average.toFixed(1)}
            </Text>
          </View>

          <View style={styles.ratingContainer}>
            <Rating
              rating={userRating}
              onRate={handleRate}
              disabled={isAnimating}
            />
          </View>

          <Text style={styles.overview}>{movie.overview}</Text>
        </View>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    height: 56,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
  },
  backButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    flex: 1,
    alignItems: 'center',
  },
  poster: {
    width: POSTER_WIDTH,
    height: POSTER_HEIGHT,
    borderRadius: 16,
  },
  info: {
    flex: 1,
    width: '100%',
    padding: 24,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#000',
    textAlign: 'center',
    marginBottom: 8,
  },
  metadata: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  year: {
    fontSize: 16,
    color: '#666',
  },
  dot: {
    fontSize: 16,
    color: '#666',
    marginHorizontal: 8,
  },
  rating: {
    fontSize: 16,
    color: '#666',
  },
  ratingContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  overview: {
    fontSize: 16,
    color: '#333',
    lineHeight: 24,
    textAlign: 'center',
  },
});

================
File: components/MatchNotification.tsx
================
import React, { useEffect } from 'react';

interface MatchNotificationProps {
  message: string;
  onClose: () => void;
}

const MatchNotification: React.FC<MatchNotificationProps> = ({ message, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(onClose, 3000); // 3 saniye sonra kapanacak
    return () => clearTimeout(timer);
  }, [onClose]);

  return (
    <div style={{
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      backgroundColor: 'rgba(0, 128, 0, 0.8)',
      color: 'white',
      padding: '20px',
      borderRadius: '5px',
      zIndex: 1000,
    }}>
      {message}
    </div>
  );
};

export default MatchNotification;

================
File: components/MovieCard.tsx
================
import React, { useState, useEffect } from 'react';
import { View, Text, Image, StyleSheet, Dimensions, TouchableWithoutFeedback, Modal, TouchableOpacity, ScrollView, StatusBar, ActivityIndicator } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { PanGestureHandler, TapGestureHandler, State } from 'react-native-gesture-handler';
import Animated, {
  useAnimatedGestureHandler,
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';

import { Movie, MovieDetails, getMovieDetails, getImageUrl } from '../lib/tmdb';
import { Rating } from './Rating';
import { useAuth } from '../contexts/auth';
import { supabase } from '../lib/supabase';
import { useTheme } from '../contexts/theme';
import { TMDB_IMAGE_URL } from '../lib/tmdb';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const SWIPE_THRESHOLD = 100;

interface MovieCardProps {
  movie: Movie;
  onAction: (action: 'watched' | 'watchlist' | 'liked' | 'disliked' | 'skip') => void;
  isAnimating: boolean;
  onRate?: (rating: number) => void;
  currentRating?: number;
}

export default function MovieCard({ movie, onAction, isAnimating = false, onRate, currentRating }: MovieCardProps) {
  const [showDetails, setShowDetails] = React.useState(false);
  const [movieDetails, setMovieDetails] = React.useState<MovieDetails | null>(null);
  const [isLoadingDetails, setIsLoadingDetails] = React.useState(false);
  const year = new Date(movie.release_date).getFullYear();
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const [rating, setRating] = useState<number>(currentRating || 0);
  const { user } = useAuth();
  const { colors } = useTheme();
  const [isFullScreen, setIsFullScreen] = useState(false);

  const handleShowDetails = React.useCallback(async () => {
    if (!isAnimating) {
      setShowDetails(true);
      setIsLoadingDetails(true);
      const details = await getMovieDetails(movie.id);
      setMovieDetails(details);
      setIsLoadingDetails(false);
    }
  }, [movie.id, isAnimating]);

  const handleMovieAction = (action: 'watched' | 'watchlist' | 'liked' | 'disliked' | 'skip') => {
    if (onAction) {
      onAction(action);
    }
  };

  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, ctx: any) => {
      ctx.startX = translateX.value;
      ctx.startY = translateY.value;
    },
    onActive: (event, ctx) => {
      translateX.value = ctx.startX + event.translationX;
      translateY.value = ctx.startY + event.translationY;
    },
    onEnd: (event) => {
      if (Math.abs(event.translationX) > SWIPE_THRESHOLD) {
        const direction = Math.sign(event.translationX);
        runOnJS(handleMovieAction)(direction > 0 ? 'liked' : 'disliked');
      } else if (event.translationY < -SWIPE_THRESHOLD) {
        runOnJS(handleMovieAction)('watchlist');
      } else {
        translateX.value = withSpring(0, { damping: 20 });
        translateY.value = withSpring(0, { damping: 20 });
      }
    },
  });

  const animatedStyle = useAnimatedStyle(() => {
    const rotate = `${(translateX.value / SCREEN_WIDTH) * 20}deg`;
    const scale = 1 - Math.abs(translateY.value / (SCREEN_WIDTH * 2));

    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { rotate },
        { scale },
      ],
    };
  });

  const overlayStyle = useAnimatedStyle(() => {
    const opacity = Math.abs(translateX.value) / (SCREEN_WIDTH / 2);
    const isRight = translateX.value > 0;
    const isUp = translateY.value < 0;

    return {
      opacity: Math.min(opacity, 1),
      backgroundColor: isUp 
        ? 'rgba(255, 215, 0, 0.3)' 
        : isRight 
          ? 'rgba(76, 175, 80, 0.3)' 
          : 'rgba(229, 9, 20, 0.3)',
    };
  });

  useEffect(() => {
    if (user?.id && movie.id) {
      loadRating();
    }
  }, [user?.id, movie.id]);

  const loadRating = async () => {
    try {
      if (!user?.id || !movie.id) return;

      const { data, error } = await supabase
        .from('movie_interactions')
        .select('action')
        .eq('user_id', user.id)
        .eq('movie_id', movie.id)
        .maybeSingle();

      if (error) throw error;
      
      setRating(data?.action === 'liked' || data?.action === 'watched' ? 5 : 0);

    } catch (error) {
      console.error('Error loading rating:', error);
    }
  };

  const renderGenres = () => {
    if (!movie.genre_ids?.length) return null;
    return (
      <View style={styles.genreContainer}>
        {movie.genre_ids.slice(0, 3).map((genreId) => (
          <View 
            key={genreId} 
            style={[styles.genreTag, { backgroundColor: colors.primary + '40' }]}
          >
            <Text style={[styles.genreText, { color: colors.text }]}>
              {getGenreName(genreId)}
            </Text>
          </View>
        ))}
      </View>
    );
  };

  const renderRating = () => (
    <View style={styles.ratingContainer}>
      <MaterialCommunityIcons name="star" size={20} color="#FFD700" />
      <Text style={[styles.ratingText, { color: colors.text }]}>
        {movie.vote_average.toFixed(1)}
      </Text>
      <Text style={[styles.voteCount, { color: colors.textSecondary }]}>
        ({formatNumber(movie.vote_count)})
      </Text>
    </View>
  );

  const renderMetaInfo = () => (
    <View style={styles.metaContainer}>
      <View style={styles.metaItem}>
        <MaterialCommunityIcons name="calendar" size={16} color={colors.textSecondary} />
        <Text style={[styles.metaText, { color: colors.textSecondary }]}>
          {new Date(movie.release_date).getFullYear()}
        </Text>
      </View>
      {movie.adult && (
        <View style={styles.metaItem}>
          <MaterialCommunityIcons name="alert-circle" size={16} color={colors.error} />
          <Text style={[styles.metaText, { color: colors.error }]}>18+</Text>
        </View>
      )}
    </View>
  );

  return (
    <TouchableWithoutFeedback onPress={handleShowDetails}>
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        <Image
          source={{
            uri: movie.poster_path
              ? `https://image.tmdb.org/t/p/w780${movie.poster_path}`
              : 'https://via.placeholder.com/780x440'
          }}
          style={styles.backdrop}
          resizeMode="cover"
        />
        <LinearGradient
          colors={['transparent', colors.background]}
          style={styles.gradient}
        >
          <View style={styles.contentContainer}>
            <View style={styles.infoContainer}>
              <Text style={[styles.title, { color: colors.text }]} numberOfLines={2}>
                {movie.title}
              </Text>

              {renderGenres()}
              {renderRating()}
              {renderMetaInfo()}

              <Text 
                style={[styles.overview, { color: colors.textSecondary }]} 
                numberOfLines={5}
              >
                {movie.overview}
              </Text>
            </View>
          </View>
        </LinearGradient>

        <View style={styles.actionButtonsContainer}>
          <TouchableOpacity
            style={[
              styles.actionButton, 
              { 
                backgroundColor: '#FF4B4B'
              }
            ]}
            onPress={() => handleMovieAction('disliked')}
            disabled={isAnimating}
          >
            <MaterialCommunityIcons name="close" size={30} color="#fff" />
          </TouchableOpacity>

          <TouchableOpacity
            style={[
              styles.actionButton, 
              { 
                backgroundColor: '#4B7BFF'
              }
            ]}
            onPress={() => handleMovieAction('watchlist')}
            disabled={isAnimating}
          >
            <MaterialCommunityIcons name="bookmark-outline" size={30} color="#fff" />
          </TouchableOpacity>

          <TouchableOpacity
            style={[
              styles.actionButton, 
              { 
                backgroundColor: '#4CAF50'
              }
            ]}
            onPress={() => handleMovieAction('liked')}
            disabled={isAnimating}
          >
            <MaterialCommunityIcons name="heart-outline" size={30} color="#fff" />
          </TouchableOpacity>
        </View>

        <Modal
          visible={showDetails}
          animationType="fade"
          onRequestClose={() => setShowDetails(false)}
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={() => setShowDetails(false)}>
            <View style={[styles.modalContainer, { backgroundColor: colors.background }]}>
              <ScrollView 
                style={styles.modalScroll}
                onTouchStart={(e) => e.stopPropagation()}
              >
                <Image
                  source={{
                    uri: movie.backdrop_path
                      ? `https://image.tmdb.org/t/p/original${movie.backdrop_path}`
                      : movie.poster_path
                        ? `https://image.tmdb.org/t/p/original${movie.poster_path}`
                        : 'https://via.placeholder.com/780x440'
                  }}
                  style={styles.modalImage}
                  resizeMode="cover"
                />
                
                <View style={styles.modalContent}>
                  <Text style={[styles.modalTitle, { color: colors.text }]}>
                    {movie.title}
                  </Text>
                  
                  <View style={styles.modalInfoRow}>
                    <Text style={styles.modalRating}>⭐ {movie.vote_average.toFixed(1)}</Text>
                    <Text style={styles.modalYear}>{year}</Text>
                    {movieDetails?.runtime && (
                      <View style={styles.runtimeContainer}>
                        <MaterialCommunityIcons name="clock-outline" size={20} color="#ccc" />
                        <Text style={styles.modalRuntime}>{movieDetails.runtime} min</Text>
                      </View>
                    )}
                  </View>
                  {movieDetails?.genres && (
                    <View style={styles.genreContainer}>
                      {movieDetails.genres.map(genre => (
                        <View key={genre.id} style={styles.genreTag}>
                          <Text style={styles.genreText}>{genre.name}</Text>
                        </View>
                      ))}
                    </View>
                  )}
                  <Text style={styles.modalDescription}>{movie.overview}</Text>
                  {isLoadingDetails ? (
                    <ActivityIndicator size="large" color="#fff" style={styles.loader} />
                  ) : movieDetails?.cast && (
                    <View style={styles.castSection}>
                      <Text style={styles.sectionTitle}>Cast</Text>
                      <ScrollView 
                        horizontal 
                        showsHorizontalScrollIndicator={false} 
                        style={styles.castScroll}
                        contentContainerStyle={styles.castScrollContent}
                      >
                        {movieDetails.cast.map(actor => (
                          <View key={actor.id} style={styles.castCard}>
                            <Image
                              source={{ 
                                uri: actor.profile_path 
                                  ? getImageUrl(actor.profile_path, 'poster')
                                  : 'https://via.placeholder.com/100x150'
                              }}
                              style={styles.castImage}
                            />
                            <Text style={styles.actorName} numberOfLines={1}>{actor.name}</Text>
                            <Text style={styles.characterName} numberOfLines={1}>{actor.character}</Text>
                          </View>
                        ))}
                      </ScrollView>
                    </View>
                  )}
                </View>
              </ScrollView>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  backdrop: {
    width: '100%',
    height: '100%',
  },
  gradient: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    height: '100%',
  },
  contentContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: 20,
  },
  infoContainer: {
    width: '100%',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  genreContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
    gap: 8,
  },
  genreTag: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginRight: 8,
    marginBottom: 4,
  },
  genreText: {
    fontSize: 14,
    fontWeight: '600',
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  ratingText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 6,
  },
  voteCount: {
    fontSize: 16,
    marginLeft: 6,
  },
  metaContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    gap: 20,
  },
  metaItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  metaText: {
    fontSize: 16,
  },
  overview: {
    fontSize: 16,
    lineHeight: 24,
    marginTop: 12,
    marginBottom: 20,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#000',
  },
  modalScroll: {
    flex: 1,
  },
  modalImage: {
    width: '100%',
    height: SCREEN_HEIGHT * 0.4,
  },
  modalContent: {
    padding: 20,
  },
  modalTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  modalInfoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginBottom: 8,
  },
  modalRating: {
    color: '#fff',
    fontSize: 16,
  },
  modalYear: {
    color: '#ccc',
    fontSize: 16,
  },
  runtimeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  modalRuntime: {
    color: '#ccc',
    fontSize: 14,
  },
  castSection: {
    marginTop: 20,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 8,
  },
  castScroll: {
    padding: 10,
  },
  castScrollContent: {
    gap: 10,
  },
  castCard: {
    width: 100,
    height: 150,
    borderRadius: 8,
    overflow: 'hidden',
  },
  castImage: {
    width: '100%',
    height: '100%',
  },
  actorName: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 4,
  },
  characterName: {
    color: '#ccc',
    fontSize: 14,
  },
  modalDescription: {
    color: '#ccc',
    fontSize: 16,
    marginTop: 12,
  },
  loader: {
    marginTop: 20,
  },
  actionButtonsContainer: {
    position: 'absolute',
    bottom: 40,
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'space-evenly',
    alignItems: 'center',
    paddingHorizontal: 20,
    zIndex: 2,
  },
  actionButton: {
    width: 70,
    height: 70,
    borderRadius: 35,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
  },
});

// Yardımcı fonksiyonlar
const GENRES: { [key: number]: string } = {
  28: 'Action',
  12: 'Adventure',
  16: 'Animation',
  35: 'Comedy',
  80: 'Crime',
  99: 'Documentary',
  18: 'Drama',
  10751: 'Family',
  14: 'Fantasy',
  36: 'History',
  27: 'Horror',
  10402: 'Music',
  9648: 'Mystery',
  10749: 'Romance',
  878: 'Science Fiction',
  10770: 'TV Movie',
  53: 'Thriller',
  10752: 'War',
  37: 'Western'
};

const getGenreName = (id: number) => GENRES[id] || 'Unknown';

const formatNumber = (num: number) => {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M';
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'K';
  }
  return num.toString();
};

================
File: components/MovieFilters.tsx
================
import React from 'react';
import { View, Text, StyleSheet, Modal, ScrollView, TouchableOpacity } from 'react-native';
import { Slider } from '@rneui/themed';
import { FilterOptions } from '../types/movies';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface MovieFiltersProps {
  visible: boolean;
  filters: FilterOptions;
  onClose: () => void;
  onApply: (filters: FilterOptions) => void;
}

export function MovieFilters({ visible, filters, onClose, onApply }: MovieFiltersProps) {
  const [tempFilters, setTempFilters] = React.useState(filters);

  const handleApply = () => {
    onApply(tempFilters);
  };

  const handleReset = () => {
    const resetFilters: FilterOptions = {
      year: { min: 1900, max: new Date().getFullYear() },
      genre: [],
      imdbRating: { min: 0, max: 10 },
      userRating: { min: 0, max: 5 }
    };
    setTempFilters(resetFilters);
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalHeader}>
          <TouchableOpacity onPress={onClose}>
            <MaterialCommunityIcons name="close" size={24} color="#000" />
          </TouchableOpacity>
          <Text style={styles.modalTitle}>Filters</Text>
          <TouchableOpacity onPress={handleReset}>
            <Text style={styles.resetText}>Reset</Text>
          </TouchableOpacity>
        </View>

        <ScrollView style={styles.modalContent}>
          {/* Yıl Filtresi */}
          <View style={styles.filterSection}>
            <Text style={styles.filterTitle}>Release Year</Text>
            <View style={styles.sliderContainer}>
              <Slider
                value={tempFilters.year.min}
                onValueChange={(value) => setTempFilters(prev => ({
                  ...prev,
                  year: { ...prev.year, min: Math.floor(value) }
                }))}
                minimumValue={1900}
                maximumValue={new Date().getFullYear()}
                step={1}
                thumbStyle={styles.thumbStyle}
                trackStyle={styles.trackStyle}
              />
              <Text style={styles.sliderValue}>From: {tempFilters.year.min}</Text>
              <Slider
                value={tempFilters.year.max}
                onValueChange={(value) => setTempFilters(prev => ({
                  ...prev,
                  year: { ...prev.year, max: Math.floor(value) }
                }))}
                minimumValue={1900}
                maximumValue={new Date().getFullYear()}
                step={1}
                thumbStyle={styles.thumbStyle}
                trackStyle={styles.trackStyle}
              />
              <Text style={styles.sliderValue}>To: {tempFilters.year.max}</Text>
            </View>
          </View>

          {/* IMDb Puanı Filtresi */}
          <View style={styles.filterSection}>
            <Text style={styles.filterTitle}>IMDb Rating</Text>
            <View style={styles.sliderContainer}>
              <Slider
                value={tempFilters.imdbRating.min}
                onValueChange={(value) => setTempFilters(prev => ({
                  ...prev,
                  imdbRating: { ...prev.imdbRating, min: value }
                }))}
                minimumValue={0}
                maximumValue={10}
                step={0.1}
                thumbStyle={styles.thumbStyle}
                trackStyle={styles.trackStyle}
              />
              <Text style={styles.sliderValue}>From: {tempFilters.imdbRating.min.toFixed(1)}</Text>
              <Slider
                value={tempFilters.imdbRating.max}
                onValueChange={(value) => setTempFilters(prev => ({
                  ...prev,
                  imdbRating: { ...prev.imdbRating, max: value }
                }))}
                minimumValue={0}
                maximumValue={10}
                step={0.1}
                thumbStyle={styles.thumbStyle}
                trackStyle={styles.trackStyle}
              />
              <Text style={styles.sliderValue}>To: {tempFilters.imdbRating.max.toFixed(1)}</Text>
            </View>
          </View>

          {/* Kullanıcı Puanı Filtresi */}
          <View style={styles.filterSection}>
            <Text style={styles.filterTitle}>Your Rating</Text>
            <View style={styles.sliderContainer}>
              <Slider
                value={tempFilters.userRating.min}
                onValueChange={(value) => setTempFilters(prev => ({
                  ...prev,
                  userRating: { ...prev.userRating, min: value }
                }))}
                minimumValue={0}
                maximumValue={5}
                step={0.5}
                thumbStyle={styles.thumbStyle}
                trackStyle={styles.trackStyle}
              />
              <Text style={styles.sliderValue}>From: {tempFilters.userRating.min.toFixed(1)}</Text>
              <Slider
                value={tempFilters.userRating.max}
                onValueChange={(value) => setTempFilters(prev => ({
                  ...prev,
                  userRating: { ...prev.userRating, max: value }
                }))}
                minimumValue={0}
                maximumValue={5}
                step={0.5}
                thumbStyle={styles.thumbStyle}
                trackStyle={styles.trackStyle}
              />
              <Text style={styles.sliderValue}>To: {tempFilters.userRating.max.toFixed(1)}</Text>
            </View>
          </View>
        </ScrollView>

        <TouchableOpacity style={styles.applyButton} onPress={handleApply}>
          <Text style={styles.applyButtonText}>Apply Filters</Text>
        </TouchableOpacity>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  resetText: {
    color: '#007AFF',
    fontSize: 16,
  },
  modalContent: {
    padding: 16,
  },
  filterSection: {
    marginBottom: 24,
  },
  filterTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  sliderContainer: {
    marginHorizontal: 8,
  },
  thumbStyle: {
    height: 20,
    width: 20,
    backgroundColor: '#007AFF',
  },
  trackStyle: {
    height: 4,
  },
  sliderValue: {
    textAlign: 'center',
    marginVertical: 8,
    color: '#666',
  },
  applyButton: {
    margin: 16,
    padding: 16,
    backgroundColor: '#007AFF',
    borderRadius: 8,
    alignItems: 'center',
  },
  applyButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: components/profile/EditProfileModal.tsx
================
import React, { useState } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  ActivityIndicator,
} from 'react-native';
import { useTheme } from '../../contexts/theme';
import { supabase } from '../../lib/supabase';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface EditProfileModalProps {
  visible: boolean;
  onClose: () => void;
  currentUser: {
    first_name: string;
    bio?: string;
  };
  onUpdate: () => void;
}

export function EditProfileModal({ visible, onClose, currentUser, onUpdate }: EditProfileModalProps) {
  const { colors } = useTheme();
  const [firstName, setFirstName] = useState(currentUser.first_name);
  const [bio, setBio] = useState(currentUser.bio || '');
  const [loading, setLoading] = useState(false);

  const handleSave = async () => {
    try {
      setLoading(true);
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      const { error } = await supabase
        .from('profiles')
        .update({
          first_name: firstName,
          bio: bio,
          updated_at: new Date().toISOString(),
        })
        .eq('id', user.id);

      if (error) throw error;
      onUpdate();
      onClose();
    } catch (error) {
      console.error('Error updating profile:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={onClose}
    >
      <View style={[styles.container, { backgroundColor: 'rgba(0,0,0,0.5)' }]}>
        <View style={[styles.content, { backgroundColor: colors.surface }]}>
          <View style={styles.header}>
            <Text style={[styles.title, { color: colors.text }]}>Edit Profile</Text>
            <TouchableOpacity onPress={onClose}>
              <MaterialCommunityIcons name="close" size={24} color={colors.text} />
            </TouchableOpacity>
          </View>

          <View style={styles.form}>
            <View style={styles.inputContainer}>
              <Text style={[styles.label, { color: colors.textSecondary }]}>Name</Text>
              <TextInput
                style={[styles.input, { 
                  backgroundColor: colors.background,
                  color: colors.text,
                }]}
                value={firstName}
                onChangeText={setFirstName}
                placeholder="Enter your name"
                placeholderTextColor={colors.textSecondary}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={[styles.label, { color: colors.textSecondary }]}>Bio</Text>
              <TextInput
                style={[styles.input, { 
                  backgroundColor: colors.background,
                  color: colors.text,
                  height: 100,
                }]}
                value={bio}
                onChangeText={setBio}
                placeholder="Tell us about yourself"
                placeholderTextColor={colors.textSecondary}
                multiline
                textAlignVertical="top"
              />
            </View>
          </View>

          <TouchableOpacity
            style={[styles.saveButton, { backgroundColor: colors.primary }]}
            onPress={handleSave}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator color="#fff" />
            ) : (
              <Text style={styles.saveButtonText}>Save Changes</Text>
            )}
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'flex-end',
  },
  content: {
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
    minHeight: '50%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  form: {
    gap: 16,
  },
  inputContainer: {
    gap: 8,
  },
  label: {
    fontSize: 14,
  },
  input: {
    padding: 12,
    borderRadius: 8,
    fontSize: 16,
  },
  saveButton: {
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 20,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

================
File: components/profile/NotificationsModal.tsx
================
import React, { useState } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Switch,
} from 'react-native';
import { useTheme } from '../../contexts/theme';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { supabase } from '../../lib/supabase';

interface NotificationsModalProps {
  visible: boolean;
  onClose: () => void;
  settings: {
    newMatches: boolean;
    newMessages: boolean;
    movieSuggestions: boolean;
  };
  onUpdate: () => void;
}

export function NotificationsModal({ visible, onClose, settings, onUpdate }: NotificationsModalProps) {
  const { colors } = useTheme();
  const [notifications, setNotifications] = useState(settings);

  const handleToggle = async (key: keyof typeof settings) => {
    try {
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      const newSettings = {
        ...notifications,
        [key]: !notifications[key],
      };

      const { error } = await supabase
        .from('notification_settings')
        .upsert({
          user_id: user.id,
          ...newSettings,
          updated_at: new Date().toISOString(),
        });

      if (error) throw error;
      setNotifications(newSettings);
      onUpdate();
    } catch (error) {
      console.error('Error updating notifications:', error);
    }
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={onClose}
    >
      <View style={[styles.container, { backgroundColor: 'rgba(0,0,0,0.5)' }]}>
        <View style={[styles.content, { backgroundColor: colors.surface }]}>
          <View style={styles.header}>
            <Text style={[styles.title, { color: colors.text }]}>Notifications</Text>
            <TouchableOpacity onPress={onClose}>
              <MaterialCommunityIcons name="close" size={24} color={colors.text} />
            </TouchableOpacity>
          </View>

          <View style={styles.settings}>
            <View style={styles.settingItem}>
              <View>
                <Text style={[styles.settingTitle, { color: colors.text }]}>New Matches</Text>
                <Text style={[styles.settingDescription, { color: colors.textSecondary }]}>
                  Get notified when you match with someone
                </Text>
              </View>
              <Switch
                value={notifications.newMatches}
                onValueChange={() => handleToggle('newMatches')}
                trackColor={{ false: colors.border, true: colors.primary }}
              />
            </View>

            <View style={styles.settingItem}>
              <View>
                <Text style={[styles.settingTitle, { color: colors.text }]}>New Messages</Text>
                <Text style={[styles.settingDescription, { color: colors.textSecondary }]}>
                  Get notified when you receive a message
                </Text>
              </View>
              <Switch
                value={notifications.newMessages}
                onValueChange={() => handleToggle('newMessages')}
                trackColor={{ false: colors.border, true: colors.primary }}
              />
            </View>

            <View style={styles.settingItem}>
              <View>
                <Text style={[styles.settingTitle, { color: colors.text }]}>Movie Suggestions</Text>
                <Text style={[styles.settingDescription, { color: colors.textSecondary }]}>
                  Get personalized movie recommendations
                </Text>
              </View>
              <Switch
                value={notifications.movieSuggestions}
                onValueChange={() => handleToggle('movieSuggestions')}
                trackColor={{ false: colors.border, true: colors.primary }}
              />
            </View>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'flex-end',
  },
  content: {
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  settings: {
    gap: 24,
  },
  settingItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  settingTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  settingDescription: {
    fontSize: 14,
  },
});

================
File: components/profile/PrivacyModal.tsx
================
import React, { useState } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Switch,
  Alert,
} from 'react-native';
import { useTheme } from '../../contexts/theme';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { supabase } from '../../lib/supabase';
import { useAuth } from '../../contexts/auth';

interface PrivacyModalProps {
  visible: boolean;
  onClose: () => void;
  settings: {
    profileVisible: boolean;
    showRatings: boolean;
  };
  onUpdate: () => void;
}

export function PrivacyModal({ visible, onClose, settings, onUpdate }: PrivacyModalProps) {
  const { colors } = useTheme();
  const { signOut } = useAuth();
  const [privacy, setPrivacy] = useState(settings);

  const handleToggle = async (key: keyof typeof settings) => {
    try {
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) throw userError;
      if (!user) return;

      const newSettings = {
        ...privacy,
        [key]: !privacy[key],
      };

      const { error } = await supabase
        .from('privacy_settings')
        .upsert({
          user_id: user.id,
          ...newSettings,
          updated_at: new Date().toISOString(),
        });

      if (error) throw error;
      setPrivacy(newSettings);
      onUpdate();
    } catch (error) {
      console.error('Error updating privacy settings:', error);
    }
  };

  const handleDeleteAccount = () => {
    Alert.alert(
      'Delete Account',
      'Are you sure you want to delete your account? This action cannot be undone.',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              const { error } = await supabase.auth.signOut();
              if (error) throw error;
              await signOut();
            } catch (error) {
              console.error('Error deleting account:', error);
            }
          },
        },
      ],
    );
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={onClose}
    >
      <View style={[styles.container, { backgroundColor: 'rgba(0,0,0,0.5)' }]}>
        <View style={[styles.content, { backgroundColor: colors.surface }]}>
          <View style={styles.header}>
            <Text style={[styles.title, { color: colors.text }]}>Privacy</Text>
            <TouchableOpacity onPress={onClose}>
              <MaterialCommunityIcons name="close" size={24} color={colors.text} />
            </TouchableOpacity>
          </View>

          <View style={styles.settings}>
            <View style={styles.settingItem}>
              <View>
                <Text style={[styles.settingTitle, { color: colors.text }]}>Profile Visibility</Text>
                <Text style={[styles.settingDescription, { color: colors.textSecondary }]}>
                  Allow others to see your profile
                </Text>
              </View>
              <Switch
                value={privacy.profileVisible}
                onValueChange={() => handleToggle('profileVisible')}
                trackColor={{ false: colors.border, true: colors.primary }}
              />
            </View>

            <View style={styles.settingItem}>
              <View>
                <Text style={[styles.settingTitle, { color: colors.text }]}>Show Ratings</Text>
                <Text style={[styles.settingDescription, { color: colors.textSecondary }]}>
                  Show your movie ratings to others
                </Text>
              </View>
              <Switch
                value={privacy.showRatings}
                onValueChange={() => handleToggle('showRatings')}
                trackColor={{ false: colors.border, true: colors.primary }}
              />
            </View>

            <TouchableOpacity
              style={[styles.deleteButton, { backgroundColor: colors.error + '20' }]}
              onPress={handleDeleteAccount}
            >
              <MaterialCommunityIcons name="delete" size={20} color={colors.error} />
              <Text style={[styles.deleteButtonText, { color: colors.error }]}>
                Delete Account
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'flex-end',
  },
  content: {
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  settings: {
    gap: 24,
  },
  settingItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  settingTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  settingDescription: {
    fontSize: 14,
  },
  deleteButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    marginTop: 20,
    gap: 8,
  },
  deleteButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
});

================
File: components/Rating.tsx
================
import React from 'react';
import { View, TouchableOpacity, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface RatingProps {
  rating: number;
  onRate?: (rating: number) => void;
  small?: boolean;
  disabled?: boolean;
  size?: number;
}

export function Rating({ rating, onRate, small, disabled, size }: RatingProps) {
  const iconSize = size || (small ? 16 : 24);

  return (
    <View style={styles.container}>
      {[1, 2, 3, 4, 5].map((star) => (
        <TouchableOpacity
          key={star}
          onPress={() => !disabled && onRate?.(star)}
          disabled={disabled}
          style={small ? styles.smallStarContainer : styles.starContainer}
        >
          <MaterialCommunityIcons
            name={star <= rating ? "star" : "star-outline"}
            size={iconSize}
            color="#FFD700"
          />
        </TouchableOpacity>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
  },
  starContainer: {
    padding: 4,
  },
  smallStarContainer: {
    padding: 2,
  },
});

================
File: components/SearchBar.tsx
================
import React from 'react';
import { View, TextInput, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface SearchBarProps {
  value: string;
  onChangeText: (text: string) => void;
  onFilter: () => void;
  onViewToggle: () => void;
  isGridView: boolean;
}

export function SearchBar({ value, onChangeText, onFilter, onViewToggle, isGridView }: SearchBarProps) {
  return (
    <View style={styles.container}>
      <View style={styles.searchRow}>
        <View style={styles.searchContainer}>
          <MaterialCommunityIcons 
            name="magnify" 
            size={24} 
            color="#666" 
          />
          <TextInput
            style={styles.input}
            value={value}
            onChangeText={onChangeText}
            placeholder="Search movies..."
            placeholderTextColor="#666"
          />
          <TouchableOpacity style={styles.filterButton} onPress={onFilter}>
            <MaterialCommunityIcons 
              name="filter-variant" 
              size={24} 
              color="#007AFF" 
            />
          </TouchableOpacity>
        </View>
        <TouchableOpacity style={styles.viewToggle} onPress={onViewToggle}>
          <MaterialCommunityIcons
            name={isGridView ? "view-list" : "view-grid"}
            size={24}
            color="#007AFF"
          />
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
    paddingTop: Platform.OS === 'ios' ? 16 : 16,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
    backgroundColor: '#fff',
  },
  searchRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  searchContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    padding: 8,
  },
  input: {
    flex: 1,
    marginLeft: 8,
    color: '#000',
    fontSize: 16,
  },
  filterButton: {
    padding: 4,
  },
  viewToggle: {
    padding: 4,
  },
});

================
File: components/WatchedMovieCard.tsx
================
import React from 'react';
import { View, Text, Image, StyleSheet, TouchableOpacity, Dimensions } from 'react-native';
import { useRouter } from 'expo-router';
import { Rating } from './Rating';
import { WatchedMovieData } from '../types/movies';
import { TMDB_IMAGE_URL } from '../lib/tmdb';
import { useTheme } from '../contexts/theme';

interface WatchedMovieCardProps {
  movie: WatchedMovieData;
  onRate?: (rating: number) => void;
  isGrid?: boolean;
  onLongPress?: () => void;
}

const SCREEN_WIDTH = Dimensions.get('window').width;

export function WatchedMovieCard({ 
  movie, 
  onRate, 
  isGrid,
  onLongPress 
}: WatchedMovieCardProps) {
  const router = useRouter();
  const { colors } = useTheme();

  const handlePress = () => {
    router.push({
      pathname: '/movie/[id]',
      params: { 
        id: movie.movies.tmdb_id || movie.movie_id,
        title: movie.movies.title
      }
    });
  };

  if (isGrid) {
    return (
      <TouchableOpacity 
        style={[styles.gridItem, { backgroundColor: colors.surface }]}
        onPress={handlePress}
        onLongPress={onLongPress}
        delayLongPress={500}
      >
        <Image
          source={{ 
            uri: movie.movies.poster_path 
              ? `${TMDB_IMAGE_URL}/w500${movie.movies.poster_path}`
              : 'https://via.placeholder.com/500x750'
          }}
          style={styles.gridPoster}
        />
        <View style={styles.gridInfo}>
          <Text 
            numberOfLines={1} 
            style={[styles.gridTitle, { color: colors.text }]}
          >
            {movie.movies.title}
          </Text>
          <Rating
            rating={movie.rating || 0}
            onRate={onRate}
            small
          />
        </View>
      </TouchableOpacity>
    );
  }

  return (
    <TouchableOpacity 
      style={[styles.listItem, { backgroundColor: colors.surface }]}
      onPress={handlePress}
      onLongPress={onLongPress}
      delayLongPress={500}
    >
      <Image
        source={{ 
          uri: movie.movies.poster_path 
            ? `${TMDB_IMAGE_URL}/w500${movie.movies.poster_path}`
            : 'https://via.placeholder.com/500x750'
        }}
        style={styles.listPoster}
      />
      <View style={styles.listInfo}>
        <Text 
          numberOfLines={2} 
          style={[styles.listTitle, { color: colors.text }]}
        >
          {movie.movies.title}
        </Text>
        <Rating
          rating={movie.rating || 0}
          onRate={onRate}
        />
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  listItem: {
    flexDirection: 'row',
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 12,
    overflow: 'hidden',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
  },
  listPoster: {
    width: 80,
    height: 120,
    resizeMode: 'cover',
  },
  listInfo: {
    flex: 1,
    padding: 12,
    justifyContent: 'space-between',
  },
  listTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  gridItem: {
    width: (SCREEN_WIDTH - 48) / 2, // 2 sütun ve kenarlardan 16px padding
    margin: 8,
    borderRadius: 12,
    overflow: 'hidden',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
  },
  gridPoster: {
    width: '100%',
    aspectRatio: 2/3,
    resizeMode: 'cover',
  },
  gridInfo: {
    padding: 12,
  },
  gridTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 8,
  },
});

================
File: contexts/auth.tsx
================
import React, { createContext, useContext, useEffect, useState } from 'react';
import { StyleSheet, View, Text } from 'react-native';
import { auth } from '../lib/firebase';
import { supabase } from '../lib/supabase';
import firebase from 'firebase/compat/app';

interface User {
  id: string;
  phoneNumber: string | null;
  firebase_uid: string;
  first_name: string;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Mevcut oturumu kontrol et
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // Auth state değişikliklerini dinle
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    return () => subscription.unsubscribe();
  }, []);

  const signOut = async () => {
    try {
      // Sign out from Firebase
      await auth.signOut();
      // Sign out from Supabase (if needed)
      await supabase.auth.signOut();
      // The _layout.tsx will automatically redirect to phone-auth
      // since the auth state change will trigger the useEffect
    } catch (error) {
      console.error('Error signing out:', error);
      throw error; // Propagate error to handle it in the component
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        loading,
        signOut,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Styles must be defined after the StyleSheet import
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  requiredFieldText: {
    color: '#ff6b6b',
    fontSize: 12,
    textAlign: 'center',
    marginTop: -15,
    marginBottom: 15,
  },
});

================
File: contexts/theme.tsx
================
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useColorScheme } from 'react-native';

interface ThemeColors {
  background: string;
  surface: string;
  text: string;
  textSecondary: string;
  primary: string;
  border: string;
  error: string;
}

export const lightTheme: ThemeColors = {
  background: '#ffffff',
  surface: '#f5f5f5',
  text: '#1a1a1a',
  textSecondary: '#666666',
  primary: '#e50914',
  border: '#e0e0e0',
  error: '#ff6b6b',
};

export const darkTheme: ThemeColors = {
  background: '#1a1a1a',
  surface: '#2a1a2a',
  text: '#ffffff',
  textSecondary: '#999999',
  primary: '#e50914',
  border: '#333333',
  error: '#ff6b6b',
};

interface ThemeContextType {
  colors: ThemeColors;
  isDark: boolean;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [colors, setColors] = useState<ThemeColors>(
    colorScheme === 'dark' ? darkTheme : lightTheme
  );

  useEffect(() => {
    setColors(colorScheme === 'dark' ? darkTheme : lightTheme);
  }, [colorScheme]);

  return (
    <ThemeContext.Provider value={{ colors, isDark: colorScheme === 'dark' }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

================
File: env.d.ts
================
declare module '@env' {
  export const EXPO_PUBLIC_SUPABASE_URL: string;
  export const EXPO_PUBLIC_SUPABASE_ANON_KEY: string;
  export const EXPO_PUBLIC_TMDB_ACCESS_TOKEN: string;
}

================
File: hooks/useNotifications.ts
================
import { useEffect, useState } from 'react';
import { supabase } from '../lib/supabase';

interface Notification {
  id: number;
  type: string;
  title: string;
  message: string;
  data: any;
  read: boolean;
  created_at: string;
}

export function useNotifications() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadNotifications();
    
    // Realtime subscription
    const subscription = supabase
      .channel('notifications')
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'notifications',
        },
        (payload) => {
          setNotifications(prev => [payload.new as Notification, ...prev]);
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const loadNotifications = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data, error } = await supabase
        .from('notifications')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setNotifications(data);
    } catch (error) {
      console.error('Error loading notifications:', error);
    } finally {
      setLoading(false);
    }
  };

  const markAsRead = async (notificationId: number) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .update({ read: true })
        .eq('id', notificationId);

      if (error) throw error;
      
      setNotifications(prev =>
        prev.map(n =>
          n.id === notificationId ? { ...n, read: true } : n
        )
      );
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  };

  return {
    notifications,
    loading,
    markAsRead,
    refresh: loadNotifications
  };
}

================
File: lib/auth.ts
================
import { supabase } from './supabase';

export interface AuthResponse {
  success: boolean;
  error?: string;
  user?: any;
}

// Email ile giriş/kayıt - doğrulama olmadan
export async function signInWithEmail(email: string): Promise<AuthResponse> {
  try {
    // Önce email ile kullanıcı var mı kontrol et
    const { data: existingUser } = await supabase
      .from('profiles')
      .select('id')
      .eq('email', email)
      .single();

    if (existingUser) {
      // Kullanıcı varsa direkt giriş yap
      const { data, error } = await supabase.auth.signInWithPassword({
        email: email,
        password: email // Basit tutuyoruz şimdilik
      });

      if (error) throw error;
      return {
        success: true,
        user: data.user
      };
    }

    // Yeni kullanıcı oluştur
    const { data, error } = await supabase.auth.signUp({
      email: email,
      password: email, // Basit tutuyoruz şimdilik
      options: {
        data: {
          email: email
        }
      }
    });

    if (error) throw error;

    // Profil oluştur
    if (data.user) {
      const { error: profileError } = await supabase
        .from('profiles')
        .insert([{
          id: data.user.id,
          email: email,
          first_name: 'User',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }]);

      if (profileError) throw profileError;
    }

    return {
      success: true,
      user: data.user
    };
  } catch (error: any) {
    console.error('Error in signInWithEmail:', error);
    return {
      success: false,
      error: error.message || 'Failed to sign in'
    };
  }
}

// Mevcut oturumu kontrol et
export async function getSession() {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    if (error) throw error;
    return session;
  } catch (error) {
    console.error('Error getting session:', error);
    return null;
  }
}

// Çıkış yap
export async function signOut(): Promise<AuthResponse> {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    return { success: true };
  } catch (error: any) {
    console.error('Error in signOut:', error);
    return {
      success: false,
      error: error.message || 'Failed to sign out'
    };
  }
}

// Auth state değişikliklerini dinle
export function onAuthStateChanged(callback: (session: any) => void) {
  return supabase.auth.onAuthStateChange((event, session) => {
    callback(session);
  });
}

================
File: lib/firebase.ts
================
import firebase from 'firebase/compat/app';
import 'firebase/compat/auth';

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAAk6l3oWQe2csyWR-YMjQSJhEW4uDWGSY",
  authDomain: "moviemate-e13c5.firebaseapp.com",
  projectId: "moviemate-e13c5",
  storageBucket: "moviemate-e13c5.firebasestorage.app",
  messagingSenderId: "355090967582",
  appId: "1:355090967582:web:980e4d389ce13be11d920f",
  measurementId: "G-6LGXNN4RZC"
};

// Initialize Firebase
if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

export const auth = firebase.auth();
export default firebase;

================
File: lib/location.ts
================
import * as Location from 'expo-location';
import { supabase } from './supabase';

export async function updateUserLocation() {
  try {
    const { status } = await Location.requestForegroundPermissionsAsync();
    if (status !== 'granted') {
      throw new Error('Permission to access location was denied');
    }

    const location = await Location.getCurrentPositionAsync({});
    const { latitude, longitude } = location.coords;

    const session = await supabase.auth.getSession();
    const userId = session.data.session?.user.id;

    if (!userId) {
      throw new Error('No authenticated user');
    }

    const { error } = await supabase
      .from('profiles')
      .update({
        location: `POINT(${longitude} ${latitude})`,
        location_updated_at: new Date().toISOString()
      })
      .eq('id', userId);

    if (error) throw error;
    return true;
  } catch (error) {
    console.error('Error updating location:', error);
    return false;
  }
}

================
File: lib/matching.ts
================
import { supabase } from './supabase';

export async function findPotentialMatches(userId: string) {
  try {
    // Önce yakındaki kullanıcıları bul
    const { data: nearbyUsers, error: locationError } = await supabase
      .rpc('get_nearby_matches', { user_id: userId });

    if (locationError) throw locationError;

    if (!nearbyUsers?.length) return [];

    // Yakındaki kullanıcıların film tercihlerini kontrol et
    const { data: matches, error: matchError } = await supabase
      .from('user_movie_preferences')
      .select(`
        user_id,
        movie_id,
        status
      `)
      .in('user_id', nearbyUsers.map(u => u.match_user_id))
      .eq('status', 'watched');

    if (matchError) throw matchError;

    // Kullanıcının kendi film tercihleri
    const { data: userPreferences, error: prefError } = await supabase
      .from('user_movie_preferences')
      .select('movie_id, status')
      .eq('user_id', userId)
      .eq('status', 'watched');

    if (prefError) throw prefError;

    // Film eşleşmelerini hesapla
    const matchScores = nearbyUsers.map(nearbyUser => {
      const userMovies = matches
        ?.filter(m => m.user_id === nearbyUser.match_user_id)
        .map(m => m.movie_id);

      const commonMovies = userPreferences
        ?.filter(p => userMovies?.includes(p.movie_id))
        .length || 0;

      return {
        userId: nearbyUser.match_user_id,
        distance: nearbyUser.distance / 1000, // Convert to km
        commonMovies,
        score: calculateMatchScore(commonMovies, nearbyUser.distance)
      };
    });

    return matchScores
      .filter(match => match.score > 0.5) // Minimum eşleşme skoru
      .sort((a, b) => b.score - a.score);

  } catch (error) {
    console.error('Error finding matches:', error);
    return [];
  }
}

function calculateMatchScore(commonMovies: number, distance: number): number {
  // Mesafe ve ortak film sayısına göre 0-1 arası bir skor hesapla
  const distanceScore = Math.max(0, 1 - (distance / 150000)); // 150km max
  const movieScore = Math.min(1, commonMovies / 10); // 10+ ortak film max skor

  // Ağırlıklı ortalama (film tercihleri daha önemli)
  return (movieScore * 0.7) + (distanceScore * 0.3);
}

================
File: lib/matching/matcher.ts
================
import { supabase } from '../supabase';

export class MovieMatcher {
  public static readonly MATCH_THRESHOLD = 0.5; // Minimum eşleşme skoru

  static async findMatches(userId: string) {
    try {
      // Kullanıcının beğendiği filmleri al
      const { data: userLikes } = await supabase
        .from('user_movie_preferences')
        .select('movie_id')
        .eq('user_id', userId)
        .eq('action', 'like');

      if (!userLikes?.length) return [];

      // Ortak film beğenilerine sahip kullanıcıları bul
      const { data: matches } = await supabase
        .rpc('find_matches', { user_id: userId });

      return matches || [];
    } catch (error) {
      console.error('Error finding matches:', error);
      return [];
    }
  }

  static async createMatch(user1Id: string, user2Id: string, matchScore: number) {
    try {
      const { data, error } = await supabase
        .from('movie_matches')
        .insert({
          user1_id: user1Id < user2Id ? user1Id : user2Id,
          user2_id: user1Id < user2Id ? user2Id : user1Id,
          match_score: matchScore,
          status: 'matched' // Otomatik eşleştir
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error creating match:', error);
      return null;
    }
  }
}

================
File: lib/matching/ml-strategy.ts
================
import { UserPreferences, MatchResult, MatchingStrategy } from './types';

export class MLMatchingStrategy implements MatchingStrategy {
  private mlModel: any; // TODO: Implement actual ML model

  calculateMatch(user1: UserPreferences, user2: UserPreferences): MatchResult {
    // ML modelini kullan (şimdilik dummy bir implementasyon)
    const prediction = {
      score: Math.random() * 100,
      explanations: ['ML based matching']
    };
    
    return {
      userId: user2.id,
      score: prediction.score,
      matchReason: prediction.explanations
    };
  }
}

================
File: lib/matching/simple-strategy.ts
================
import { UserPreferences, MatchResult, MatchingStrategy } from './types';

export class SimpleMatchingStrategy implements MatchingStrategy {
  calculateMatch(user1: UserPreferences, user2: UserPreferences): MatchResult {
    let score = 0;
    const matchReason: string[] = [];

    // Genre-based matching (30% of total score)
    const commonGenres = user1.genres.filter(genre => 
      user2.genres.includes(genre)
    );
    const genreScore = (commonGenres.length / Math.max(user1.genres.length, user2.genres.length)) * 30;
    score += genreScore;
    
    if (commonGenres.length > 0) {
      matchReason.push(`Ortak ${commonGenres.length} film türü: ${commonGenres.join(', ')}`);
    }

    // Favorite movies matching (40% of total score)
    const commonFavorites = user1.favoriteMovies.filter(movie => 
      user2.favoriteMovies.includes(movie)
    );
    const favoriteScore = (commonFavorites.length / Math.max(user1.favoriteMovies.length, user2.favoriteMovies.length)) * 40;
    score += favoriteScore;

    if (commonFavorites.length > 0) {
      matchReason.push(`${commonFavorites.length} ortak favori film`);
    }

    // Rating similarity (30% of total score)
    const commonRatedMovies = Object.keys(user1.ratings).filter(movieId => 
      movieId in user2.ratings
    );
    
    if (commonRatedMovies.length > 0) {
      let ratingDiffSum = 0;
      commonRatedMovies.forEach(movieId => {
        ratingDiffSum += Math.abs(user1.ratings[movieId] - user2.ratings[movieId]);
      });
      const avgRatingDiff = ratingDiffSum / commonRatedMovies.length;
      const ratingScore = ((5 - avgRatingDiff) / 5) * 30; // 5 is max rating difference
      score += ratingScore;

      matchReason.push(`${commonRatedMovies.length} ortak değerlendirilen film`);
    }

    return {
      userId: user2.id, // user2.userId yerine user2.id kullan
      score: Math.round(score),
      matchReason
    };
  }
}

export function calculateMatchScore(user1: UserPreferences, user2: UserPreferences): number {
  const weights = {
    favoriteMovies: 0.4,  // Ortak beğenilen filmlerin ağırlığı
    genres: 0.3,          // Ortak türlerin ağırlığı
    ratings: 0.2,         // Benzer değerlendirmelerin ağırlığı
    watchlist: 0.1        // İzleme listesindeki benzerliklerin ağırlığı
  };

  // 1. Ortak beğenilen filmler skoru
  const commonFavorites = user1.favoriteMovies.filter(movie => 
    user2.favoriteMovies.includes(movie)
  ).length;
  const favoriteMoviesScore = commonFavorites / 
    Math.max(1, Math.min(user1.favoriteMovies.length, user2.favoriteMovies.length));

  // 2. Ortak film türleri skoru
  const commonGenres = user1.genres.filter(genre => 
    user2.genres.includes(genre)
  ).length;
  const genresScore = commonGenres / 
    Math.max(1, Math.min(user1.genres.length, user2.genres.length));

  // 3. Film değerlendirmeleri benzerlik skoru
  let ratingsScore = 0;
  let commonRatings = 0;
  
  // Ortak değerlendirilen filmlerin benzerlik skorunu hesapla
  Object.keys(user1.ratings).forEach(movieId => {
    if (user2.ratings[movieId]) {
      commonRatings++;
      // Değerlendirme farkının mutlak değerini al (1-5 arası)
      const ratingDiff = Math.abs(user1.ratings[movieId] - user2.ratings[movieId]);
      // Farkı 0-1 arasında bir skora dönüştür
      ratingsScore += 1 - (ratingDiff / 4);
    }
  });
  
  // En az 3 ortak değerlendirme varsa skoru hesapla
  const finalRatingsScore = commonRatings >= 3 ? 
    ratingsScore / commonRatings : 0;

  // 4. İzleme listesi benzerlik skoru
  const commonWatchlist = user1.watchlist.filter(movie => 
    user2.watchlist.includes(movie)
  ).length;
  const watchlistScore = commonWatchlist / 
    Math.max(1, Math.min(user1.watchlist.length, user2.watchlist.length));

  // Toplam skoru hesapla
  const totalScore = (
    favoriteMoviesScore * weights.favoriteMovies +
    genresScore * weights.genres +
    finalRatingsScore * weights.ratings +
    watchlistScore * weights.watchlist
  );

  // Minimum eşleşme kriterleri
  const minimumCriteria = {
    commonFavorites: 1,   // En az 1 ortak beğenilen film
    commonGenres: 2,      // En az 2 ortak tür
    totalScore: 0.3       // Minimum toplam skor
  };

  // Minimum kriterleri kontrol et
  if (commonFavorites < minimumCriteria.commonFavorites ||
      commonGenres < minimumCriteria.commonGenres ||
      totalScore < minimumCriteria.totalScore) {
    return 0;
  }

  return totalScore;
}

// Bonus özellik: Detaylı eşleşme açıklaması
export function getMatchDetails(user1: UserPreferences, user2: UserPreferences) {
  const commonMovies = user1.favoriteMovies.filter(movie => 
    user2.favoriteMovies.includes(movie)
  );
  
  const commonGenres = user1.genres.filter(genre => 
    user2.genres.includes(genre)
  );

  return {
    commonMovies,
    commonGenres,
    commonMoviesCount: commonMovies.length,
    commonGenresCount: commonGenres.length,
    commonRatingsCount: Object.keys(user1.ratings)
      .filter(movieId => user2.ratings[movieId])
      .length
  };
}

================
File: lib/matching/types.ts
================
// Temel kullanıcı özellikleri için interface
export interface UserPreferences {
  id: string;           // userId ekleyelim
  genres: string[];          // Tercih edilen film türleri
  favoriteMovies: string[]; // Favori filmler
  watchlist: string[];      // İzleme listesi
  ratings: { [movieId: string]: number }; // Film değerlendirmeleri
}

// Eşleştirme sonucu için interface
export interface MatchResult {
  userId: string;
  score: number;
  matchReason: string[];
}

// Eşleştirme stratejisi için interface
export interface MatchingStrategy {
  calculateMatch(user1: UserPreferences, user2: UserPreferences): MatchResult;
}

================
File: lib/movies.ts
================
import { supabase } from './supabase';
import { WatchedMovieData, FilterOptions } from '../types/movies';

export async function loadWatchedMovies(
  userId: string,
  filters: FilterOptions,
  searchQuery: string
): Promise<WatchedMovieData[]> {
  try {
    // user_movie_preferences tablosundan verileri al
    const { data: watchedMovies, error: watchedError } = await supabase
      .from('user_movie_preferences')
      .select(`
        movie_id,
        movies!inner (
          title,
          poster_path,
          vote_average,
          release_date
        ),
        created_at
      `)
      .eq('user_id', userId)
      .eq('status', 'watched')
      .gte('movies.release_date', `${filters.year.min}-01-01`)
      .lte('movies.release_date', `${filters.year.max}-12-31`)
      .gte('movies.vote_average', filters.imdbRating.min)
      .lte('movies.vote_average', filters.imdbRating.max)
      .order('created_at', { ascending: false });

    if (watchedError) throw watchedError;

    // user_ratings tablosundan verileri al
    const { data: ratings, error: ratingsError } = await supabase
      .from('user_ratings')
      .select('movie_id, rating')
      .eq('user_id', userId);

    if (ratingsError) throw ratingsError;

    // Filmleri ve kullanıcı puanlarını birleştir
    const movies = watchedMovies.map(movie => ({
      movie_id: movie.movie_id,
      movies: movie.movies,
      user_ratings: ratings
        ?.filter(r => r.movie_id === movie.movie_id)
        .map(r => ({ rating: r.rating })) || [],
      created_at: movie.created_at
    }));

    // Arama filtresini uygula
    return movies.filter(movie => {
      const matchesSearch = searchQuery
        ? movie.movies.title.toLowerCase().includes(searchQuery.toLowerCase())
        : true;

      const userRating = movie.user_ratings[0]?.rating || 0;
      const matchesUserRating = userRating >= filters.userRating.min && 
                               userRating <= filters.userRating.max;

      return matchesSearch && matchesUserRating;
    });

  } catch (error) {
    console.error('Error in loadWatchedMovies:', error);
    throw error;
  }
}

================
File: lib/profile.ts
================
import { supabase } from './supabase';

// Profil oluştur
export async function createProfile(data: {
  firebase_uid: string;
  first_name: string;
}) {
  try {
    console.log('Creating profile for:', data.first_name);
    
    const { data: profile, error } = await supabase
      .from('profiles')
      .insert({
        firebase_uid: data.firebase_uid,
        first_name: data.first_name,
        onboarding_completed: true
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating profile:', error);
      throw error;
    }

    return { profile, error: null };
  } catch (error) {
    console.error('Error creating profile:', error);
    return { profile: null, error };
  }
}

// Profil getir
export async function getProfile(firebaseUid: string) {
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('firebase_uid', firebaseUid)
      .single();

    return { profile: data, error };
  } catch (error) {
    console.error('Error fetching profile:', error);
    return { profile: null, error };
  }
}

// Profil güncelle
export async function updateProfile(
  firebaseUid: string,
  updates: {
    first_name?: string;
    phone_number?: string;
    avatar_url?: string;
  }
) {
  try {
    const { data, error } = await supabase
      .from('profiles')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('firebase_uid', firebaseUid)
      .select()
      .single();

    return { profile: data, error };
  } catch (error) {
    console.error('Error updating profile:', error);
    return { profile: null, error };
  }
}

================
File: lib/supabase.ts
================
import 'react-native-url-polyfill/auto';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';
import { Platform, Alert } from 'react-native';

// Constants for chunked storage
const CHUNK_SIZE = 1800; // Safely under 2048 byte limit

// Helper functions for chunked storage
const chunkString = (str: string): string[] => {
  const chunks: string[] = [];
  for (let i = 0; i < str.length; i += CHUNK_SIZE) {
    chunks.push(str.slice(i, i + CHUNK_SIZE));
  }
  return chunks;
};

const getChunkKey = (key: string, index: number) => `${key}_chunk_${index}`;
const getChunkCountKey = (key: string) => `${key}_chunk_count`;

// Custom storage adapter for web platform
const webStorage = {
  getItem: (key: string) => {
    try {
      return Promise.resolve(localStorage.getItem(key));
    } catch (error) {
      return Promise.reject(error);
    }
  },
  setItem: (key: string, value: string) => {
    try {
      localStorage.setItem(key, value);
      return Promise.resolve(undefined);
    } catch (error) {
      return Promise.reject(error);
    }
  },
  removeItem: (key: string) => {
    try {
      localStorage.removeItem(key);
      return Promise.resolve(undefined);
    } catch (error) {
      return Promise.reject(error);
    }
  },
};

// Use SecureStore on native platforms, localStorage on web
const storage = Platform.OS === 'web' ? webStorage : {
  getItem: async (key: string) => {
    try {
      // Try to get chunk count
      const countStr = await SecureStore.getItemAsync(getChunkCountKey(key));
      
      if (!countStr) {
        // No chunks, try regular get
        return SecureStore.getItemAsync(key);
      }

      // Reassemble chunks
      const count = parseInt(countStr, 10);
      const chunks: string[] = [];
      
      for (let i = 0; i < count; i++) {
        const chunk = await SecureStore.getItemAsync(getChunkKey(key, i));
        if (chunk) chunks.push(chunk);
      }
      
      return chunks.join('');
    } catch (error) {
      console.error('Error getting item:', error);
      return null;
    }
  },
  setItem: async (key: string, value: string) => {
    try {
      if (value.length < CHUNK_SIZE) {
        // Store directly if small enough
        await SecureStore.setItemAsync(key, value);
        // Clean up any existing chunks
        const oldCountStr = await SecureStore.getItemAsync(getChunkCountKey(key));
        if (oldCountStr) {
          const oldCount = parseInt(oldCountStr, 10);
          for (let i = 0; i < oldCount; i++) {
            await SecureStore.deleteItemAsync(getChunkKey(key, i));
          }
          await SecureStore.deleteItemAsync(getChunkCountKey(key));
        }
        return;
      }

      // Split into chunks and store
      const chunks = chunkString(value);
      await SecureStore.setItemAsync(getChunkCountKey(key), chunks.length.toString());
      
      for (let i = 0; i < chunks.length; i++) {
        await SecureStore.setItemAsync(getChunkKey(key, i), chunks[i]);
      }
    } catch (error) {
      console.error('Error setting item:', error);
      throw error;
    }
  },
  removeItem: async (key: string) => {
    try {
      // Remove main item
      await SecureStore.deleteItemAsync(key);
      
      // Check and remove chunks if they exist
      const countStr = await SecureStore.getItemAsync(getChunkCountKey(key));
      if (countStr) {
        const count = parseInt(countStr, 10);
        for (let i = 0; i < count; i++) {
          await SecureStore.deleteItemAsync(getChunkKey(key, i));
        }
        await SecureStore.deleteItemAsync(getChunkCountKey(key));
      }
    } catch (error) {
      console.error('Error removing item:', error);
      throw error;
    }
  },
};

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase URL or Anonymous Key');
}

// Debug function to check bucket existence
export const checkAvatarsBucket = async () => {
  try {
    const { data, error } = await supabase
      .storage
      .getBucket('avatars');
    
    console.log('Bucket check result:', { data, error });
    return { data, error };
  } catch (error) {
    console.error('Error checking bucket:', error);
    return { data: null, error };
  }
};

// Test avatar upload
export const testAvatarUpload = async (imageUri: string) => {
  try {
    console.log('Starting test upload for:', imageUri);
    
    // Check if bucket exists first
    const { error: bucketError } = await checkAvatarsBucket();
    if (bucketError) {
      console.error('Bucket error:', bucketError);
      throw new Error('Avatar storage is not properly configured');
    }

    const response = await fetch(imageUri);
    if (!response.ok) {
      console.error('Failed to fetch image:', response.status);
      throw new Error('Failed to fetch image');
    }

    const blob = await response.blob();
    if (!blob) {
      console.error('Failed to create blob');
      throw new Error('Failed to create blob from image');
    }

    console.log('Blob created:', {
      size: blob.size,
      type: blob.type
    });

    const fileName = `test-${Date.now()}.jpg`;

    const { data, error } = await supabase.storage
      .from('avatars')
      .upload(fileName, blob, {
        contentType: blob.type,
        upsert: true
      });

    if (error) {
      console.error('Upload error:', error);
      return { error };
    }

    console.log('Upload successful:', data);

    // List files in bucket to verify upload
    const { data: files, error: listError } = await supabase.storage
      .from('avatars')
      .list();
    
    if (!listError) {
      console.log('Files in bucket:', files);
    }

    const { data: { publicUrl } } = supabase.storage
      .from('avatars')
      .getPublicUrl(fileName);

    console.log('Public URL:', publicUrl);
    return { url: publicUrl, error: null };
  } catch (error) {
    console.error('Test upload error:', error);
    return { error };
  }
};

// Sadece database client - auth özelliklerini tamamen devre dışı bırak
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
    detectSessionInUrl: false
  }
});

// Veritabanı bağlantısını test et
export const testDatabaseConnection = async () => {
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .limit(1);

    if (error) {
      console.error('Database connection error:', error);
      return false;
    }
    return true;
  } catch (error) {
    console.error('Database test error:', error);
    return false;
  }
};

// Firebase UID ile profil kontrolü
export async function checkProfile(firebaseUid: string) {
  try {
    console.log('Checking profile for Firebase UID:', firebaseUid);
    
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('firebase_uid', firebaseUid)
      .maybeSingle();

    if (error) {
      console.error('Profile check error:', error);
      throw error;
    }

    console.log('Profile check result:', data);
    return { exists: !!data, profile: data };
  } catch (error) {
    console.error('Error checking profile:', error);
    return { exists: false, profile: null };
  }
}

================
File: lib/supabase/users.ts
================
import { supabase } from '../supabase';

// Tip tanımlamaları
interface UserPreferences {
  id: string;
  genres: number[];
  favoriteMovies: number[];
  watchlist: number[];
  ratings: Record<number, number>;
}

interface MoviePreference {
  user_id: string;
  movie_id: number;
  status: string;
  liked: boolean;
}

interface GenrePreference {
  genre_id: number;
}

interface Rating {
  movie_id: number;
  rating: number;
}

interface MovieInteraction {
  movie_id: number;
  action: 'watched' | 'watchlist' | 'liked' | 'disliked';
  rating?: number;
  created_at: string;
  movie?: {
    id: number;
    title: string;
    poster_path: string;
    genre_ids: number[];
  };
}

interface SupabaseProfile {
  firebase_uid: string;
  first_name: string;
  avatar_url: string | null;
}

interface MatchResponse {
  id: string;
  match_score: number;
  user1: {
    firebase_uid: string;
    first_name: string;
    avatar_url: string | null;
  };
  user2: {
    firebase_uid: string;
    first_name: string;
    avatar_url: string | null;
  };
}

interface MatchData {
  id: string;
  match_score: number;
  user1_id: string;
  user2_id: string;
  user1: {
    firebase_uid: string;
    first_name: string;
    avatar_url: string | null;
  };
  user2: {
    firebase_uid: string;
    first_name: string;
    avatar_url: string | null;
  };
}

interface Match {
  id: string;
  match_score: number;
  user1: {
    id: string;
    first_name: string;
    avatar_url: string | null;
  };
  user2: {
    id: string;
    first_name: string;
    avatar_url: string | null;
  };
}

// Film etkileşimlerini getir
export async function getMovieInteractions(userId: string) {
  const { data, error } = await supabase
    .from('movie_interactions')
    .select('*')
    .eq('firebase_uid', userId);

  if (error) {
    console.error('Error fetching movie interactions:', error);
    return [];
  }

  return data;
}

// Film etkileşimi ekle/güncelle
export async function setMovieInteraction(
  userId: string,
  movieId: number,
  interaction: {
    action: 'watched' | 'watchlist' | 'liked' | 'disliked';
    rating?: number;
  }
) {
  const { error } = await supabase
    .from('movie_interactions')
    .upsert({
      firebase_uid: userId,
      movie_id: movieId,
      action: interaction.action,
      rating: interaction.rating,
      updated_at: new Date().toISOString()
    });

  if (error) {
    console.error('Error setting movie interaction:', error);
    return false;
  }

  return true;
}

// Film değerlendirmesini güncelle
export async function updateMovieRating(
  userId: string,
  movieId: number,
  rating: number
) {
  const { error } = await supabase
    .from('movie_interactions')
    .update({
      rating: rating,
      action: 'watched', // Rating varsa watched olarak işaretle
      updated_at: new Date().toISOString()
    })
    .eq('firebase_uid', userId)
    .eq('movie_id', movieId);

  if (error) {
    console.error('Error updating movie rating:', error);
    return false;
  }

  return true;
}

// Kullanıcının izlediği filmleri getir
export async function getWatchedMovies(userId: string) {
  const { data, error } = await supabase
    .from('movie_interactions')
    .select('movie_id, rating, action')
    .eq('firebase_uid', userId)
    .eq('action', 'watched');

  if (error) {
    console.error('Error fetching watched movies:', error);
    return [];
  }

  return data;
}

// Kullanıcının watchlist'ini getir
export async function getWatchlist(userId: string) {
  const { data, error } = await supabase
    .from('movie_interactions')
    .select('movie_id')
    .eq('firebase_uid', userId)
    .eq('action', 'watchlist');

  if (error) {
    console.error('Error fetching watchlist:', error);
    return [];
  }

  return data.map(item => item.movie_id);
}

// Eşleşmeleri getir
export async function getMatches(userId: string): Promise<Match[]> {
  const { data, error } = await supabase
    .from('matches')
    .select<'matches', MatchData>(`
      id,
      match_score,
      user1_id,
      user2_id,
      user1:profiles(firebase_uid, first_name, avatar_url),
      user2:profiles(firebase_uid, first_name, avatar_url)
    `)
    .or(`user1_id.eq.${userId},user2_id.eq.${userId}`)
    .order('match_score', { ascending: false });

  if (error) {
    console.error('Error fetching matches:', error);
    return [];
  }

  return (data || []).map(match => ({
    id: match.id,
    match_score: match.match_score,
    user1: {
      id: match.user1?.firebase_uid || '',
      first_name: match.user1?.first_name || '',
      avatar_url: match.user1?.avatar_url
    },
    user2: {
      id: match.user2?.firebase_uid || '',
      first_name: match.user2?.first_name || '',
      avatar_url: match.user2?.avatar_url
    }
  }));
}

// Eşleşme skoru hesapla ve kaydet
export async function calculateAndSaveMatch(user1Id: string, user2Id: string) {
  try {
    // Eşleşme skorunu hesapla
    const { data: score, error: scoreError } = await supabase
      .rpc('calculate_match_score', { 
        user1_id: user1Id,
        user2_id: user2Id 
      });

    if (scoreError) throw scoreError;

    // Eşleşmeyi kaydet
    const { error: matchError } = await supabase
      .from('matches')
      .upsert({
        user1_id: user1Id,
        user2_id: user2Id,
        match_score: score,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'user1_id,user2_id'
      });

    if (matchError) throw matchError;

    return true;
  } catch (error) {
    console.error('Error calculating/saving match:', error);
    return false;
  }
}

// Profil getir
export async function getUserProfile(userId: string) {
  const { data, error } = await supabase
    .from('profiles')
    .select('*')
    .eq('firebase_uid', userId)
    .single();

  if (error) {
    console.error('Error fetching user profile:', error);
    return null;
  }

  return data;
}

// Test fonksiyonu
export async function testMatchMechanism(userId: string) {
  try {
    // 1. Kullanıcının tercihlerini kontrol et
    const userPrefs = await getMovieInteractions(userId);
    console.log('User Preferences:', userPrefs);

    // 2. Mevcut eşleşmeleri kontrol et
    const currentMatches = await getMatches(userId);
    console.log('Current Matches:', currentMatches);

    // 3. Trigger'ın çalışıp çalışmadığını kontrol et
    const { data: triggerTest, error: triggerError } = await supabase
      .from('user_movie_preferences')
      .select('*')
      .eq('user_id', userId)
      .limit(1);

    if (triggerError) {
      console.error('Trigger test error:', triggerError);
      return false;
    }

    // 4. Eşleşme skorlarını kontrol et
    const { data: matchScores, error: matchError } = await supabase
      .rpc('calculate_match_score', { 
        user1_id: userId,
        user2_id: triggerTest?.[0]?.user_id 
      });

    if (matchError) {
      console.error('Match score calculation error:', matchError);
      return false;
    }

    console.log('Match Scores:', matchScores);
    return true;

  } catch (error) {
    console.error('Test failed:', error);
    return false;
  }
}

// Kullanıcı profili kontrol et
export async function checkProfile(firebaseUid: string) {
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('firebase_uid', firebaseUid)
      .maybeSingle();

    if (error) throw error;
    return { exists: !!data, profile: data };
  } catch (error) {
    console.error('Error checking profile:', error);
    return { exists: false, profile: null };
  }
}

// Ayrıca createMatch fonksiyonunu ekleyelim (matches.tsx'te kullanılıyor)
export async function createMatch(user1Id: string, user2Id: string, matchScore: number) {
  try {
    const { error } = await supabase
      .from('matches')
      .upsert({
        user1_id: user1Id,
        user2_id: user2Id,
        match_score: matchScore,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'user1_id,user2_id'
      });

    if (error) throw error;
    return true;
  } catch (error) {
    console.error('Error creating match:', error);
    return false;
  }
}

================
File: lib/tmdb.ts
================
const TMDB_ACCESS_TOKEN = process.env.EXPO_PUBLIC_TMDB_ACCESS_TOKEN;
const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
const CACHE_DURATION = 1000 * 60 * 15; // 15 minutes
let lastFetchTime = 0;
let cachedMovies: Movie[] = [];

export interface Movie {
  id: number;
  title: string;
  overview: string;
  poster_path: string | null;
  backdrop_path: string | null;
  release_date: string;
  vote_average: number;
  vote_count: number;
  adult: boolean;
  genre_ids: number[];
}

export interface Cast {
  id: number;
  name: string;
  character: string;
  profile_path: string | null;
}

export interface MovieDetails extends Movie {
  runtime: number;
  genres: { id: number; name: string }[];
  cast: Cast[];
}

export const TMDB_IMAGE_URL = 'https://image.tmdb.org/t/p';

async function fetchFromTMDB(endpoint: string, page = 1): Promise<Movie[]> {
  if (!TMDB_ACCESS_TOKEN) {
    console.error('TMDB access token is missing');
    return [];
  }

  try {
    const response = await fetch(
      `${TMDB_BASE_URL}${endpoint}?include_adult=false&include_video=false&language=en-US&page=${page}`,
      {
        headers: {
          'Authorization': `Bearer ${TMDB_ACCESS_TOKEN}`,
          'accept': 'application/json'
        }
      }
    );
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.status_message || 'Failed to fetch movies');
    }
    
    const data = await response.json();
    return data.results || [];
  } catch (error) {
    console.error('Error fetching from TMDB:', error);
    return [];
  }
}

export async function getPopularMovies(page = 1): Promise<Movie[]> {
  return fetchFromTMDB('/discover/movie?sort_by=popularity.desc', page);
}

export async function getTopRatedMovies(page = 1): Promise<Movie[]> {
  return fetchFromTMDB('/movie/top_rated', page);
}

export async function getTrendingMovies(page = 1): Promise<Movie[]> {
  return fetchFromTMDB('/trending/movie/week', page);
}

export async function getUpcomingMovies(page = 1): Promise<Movie[]> {
  return fetchFromTMDB('/movie/upcoming', page);
}

export function getImageUrl(path: string, size: 'poster' | 'backdrop' = 'poster'): string {
  if (!path) return 'https://images.unsplash.com/photo-1440404653325-ab127d49abc1?w=800';
  const baseUrl = 'https://image.tmdb.org/t/p';
  const imageSize = size === 'poster' ? 'w500' : 'original';
  return `${baseUrl}/${imageSize}${path}`;
}

export async function getMovieDetails(movieId: number): Promise<MovieDetails | null> {
  if (!TMDB_ACCESS_TOKEN) {
    console.error('TMDB access token is missing');
    return null;
  }

  try {
    // Fetch movie details
    const [detailsResponse, creditsResponse] = await Promise.all([
      fetch(
        `${TMDB_BASE_URL}/movie/${movieId}?language=en-US`,
        {
          headers: {
            'Authorization': `Bearer ${TMDB_ACCESS_TOKEN}`,
            'accept': 'application/json'
          }
        }
      ),
      fetch(
        `${TMDB_BASE_URL}/movie/${movieId}/credits?language=en-US`,
        {
          headers: {
            'Authorization': `Bearer ${TMDB_ACCESS_TOKEN}`,
            'accept': 'application/json'
          }
        }
      )
    ]);

    if (!detailsResponse.ok || !creditsResponse.ok) {
      throw new Error('Failed to fetch movie details');
    }

    const [details, credits] = await Promise.all([
      detailsResponse.json(),
      creditsResponse.json()
    ]);

    return {
      ...details,
      cast: credits.cast.slice(0, 10), // Get top 10 cast members
      tmdb_data: details.tmdb_data // Assuming tmdb_data is available in the details object
    };
  } catch (error) {
    console.error('Error fetching movie details:', error);
    return null;
  }
}

async function saveMovie(newMovie) {
  // ...
  const movieData = {
    // ...
    tmdb_data: newMovie.tmdb_data,
    // ...
  };
  // ...
}

================
File: lib/tmdb/genres.ts
================
export const movieGenres = [
  { id: '28', name: 'Action' },
  { id: '12', name: 'Adventure' },
  { id: '16', name: 'Animation' },
  { id: '35', name: 'Comedy' },
  { id: '80', name: 'Crime' },
  { id: '99', name: 'Documentary' },
  { id: '18', name: 'Drama' },
  { id: '10751', name: 'Family' },
  { id: '14', name: 'Fantasy' },
  { id: '36', name: 'History' },
  { id: '27', name: 'Horror' },
  { id: '10402', name: 'Music' },
  { id: '9648', name: 'Mystery' },
  { id: '10749', name: 'Romance' },
  { id: '878', name: 'Science Fiction' },
  { id: '10770', name: 'TV Movie' },
  { id: '53', name: 'Thriller' },
  { id: '10752', name: 'War' },
  { id: '37', name: 'Western' }
];

================
File: lib/types.ts
================
export interface Profile {
  id: string;
  email: string;
  first_name: string;
  avatar_url: string | null;
  created_at: string;
  updated_at: string;
}

export interface Match {
  id: string;
  user1_id: string;
  user2_id: string;
  created_at: string;
  updated_at: string;
  status: 'pending' | 'accepted' | 'rejected';
}

export interface Movie {
  id: number;
  title: string;
  overview: string;
  poster_path: string | null;
  backdrop_path: string | null;
  release_date: string;
  vote_average: number;
  vote_count: number;
  adult: boolean;
  genre_ids: number[];
  genres?: { id: number; name: string }[];
}

export interface MovieInteraction {
  id: string;
  user_id: string;
  movie_id: number;
  action: 'watched' | 'watchlist' | 'liked' | 'disliked' | 'skip';
  created_at: string;
}

// ... diğer interface'ler aynı kalacak

================
File: package.json
================
{
  "name": "movie-mate",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "expo start",
    "build:web": "expo export --platform web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.4",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/slider": "^4.5.6",
    "@react-native-firebase/auth": "^21.11.0",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/stack": "^7.1.1",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@supabase/supabase-js": "^2.39.3",
    "@types/firebase": "^2.4.32",
    "base64-arraybuffer": "^1.0.2",
    "date-fns": "^4.1.0",
    "expo": "52.0.33",
    "expo-auth-session": "~5.4.0",
    "expo-blur": "^14.0.3",
    "expo-build-properties": "~0.13.2",
    "expo-constants": "^17.0.5",
    "expo-firebase-auth": "^2.0.0",
    "expo-firebase-core": "^6.0.0",
    "expo-firebase-recaptcha": "^2.3.1",
    "expo-font": "^13.0.3",
    "expo-haptics": "^14.0.1",
    "expo-image-picker": "~14.7.1",
    "expo-linear-gradient": "^14.0.2",
    "expo-linking": "~7.0.5",
    "expo-router": "^4.0.17",
    "expo-secure-store": "~12.8.1",
    "expo-splash-screen": "^0.29.21",
    "expo-status-bar": "^2.0.1",
    "expo-system-ui": "^4.0.7",
    "expo-web-browser": "^14.0.2",
    "firebase": "^9.23.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.6",
    "react-native-gesture-handler": "^2.23.0",
    "react-native-reanimated": "^3.16.7",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "^4.4.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-web": "^0.19.13",
    "react-navigation-shared-element": "^3.1.3",
    "use-debounce": "^10.0.4"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "supabase": "^2.12.1",
    "typescript": "^5.3.3"
  }
}

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "project"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"
# Specifies static files to be bundled with the function. Supports glob patterns.
# For example, if you want to serve static HTML pages in your function:
# static_files = [ "./functions/MY_FUNCTION_NAME/*.html" ]

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: supabase/migrations/20240320000000_create_initial_schema.sql
================
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create profiles table
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  first_name TEXT,
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Create movie_interactions table
CREATE TABLE movie_interactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  movie_id INTEGER NOT NULL,
  title TEXT NOT NULL,
  poster_path TEXT,
  action TEXT NOT NULL CHECK (action IN ('watched', 'watchlist', 'liked', 'disliked', 'skip')),
  rating INTEGER CHECK (rating >= 0 AND rating <= 5),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(user_id, movie_id)
);

-- Create matches table
CREATE TABLE matches (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user1_id UUID REFERENCES auth.users(id) NOT NULL,
  user2_id UUID REFERENCES auth.users(id) NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected')),
  match_score INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(user1_id, user2_id)
);

-- Create messages table
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  match_id UUID REFERENCES matches(id) NOT NULL,
  sender_id UUID REFERENCES auth.users(id) NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Create user_genres table
CREATE TABLE user_genres (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  firebase_uid UUID REFERENCES auth.users(id) NOT NULL,
  genre_id TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(firebase_uid, genre_id)
);

-- Create notification_settings table
CREATE TABLE notification_settings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  new_matches BOOLEAN DEFAULT true,
  new_messages BOOLEAN DEFAULT true,
  movie_suggestions BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(user_id)
);

-- Create privacy_settings table
CREATE TABLE privacy_settings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  profile_visible BOOLEAN DEFAULT true,
  show_ratings BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(user_id)
);

-- Create RLS policies
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE movie_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE matches ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE privacy_settings ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Public profiles are viewable by everyone"
ON profiles FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
TO authenticated
USING (auth.uid() = id);

-- Movie interactions policies
CREATE POLICY "Users can view own movie interactions"
ON movie_interactions FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users can create own movie interactions"
ON movie_interactions FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own movie interactions"
ON movie_interactions FOR UPDATE
TO authenticated
USING (auth.uid() = user_id);

-- Matches policies
CREATE POLICY "Users can view their matches"
ON matches FOR SELECT
TO authenticated
USING (auth.uid() = user1_id OR auth.uid() = user2_id);

CREATE POLICY "Users can create matches"
ON matches FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user1_id);

-- Messages policies
CREATE POLICY "Users can view messages in their matches"
ON messages FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM matches
    WHERE id = messages.match_id
    AND (user1_id = auth.uid() OR user2_id = auth.uid())
  )
);

CREATE POLICY "Users can send messages in their matches"
ON messages FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1 FROM matches
    WHERE id = match_id
    AND (user1_id = auth.uid() OR user2_id = auth.uid())
  )
);

-- Create functions and triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc', NOW());
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER update_matches_updated_at
    BEFORE UPDATE ON matches
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER update_notification_settings_updated_at
    BEFORE UPDATE ON notification_settings
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER update_privacy_settings_updated_at
    BEFORE UPDATE ON privacy_settings
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "esModuleInterop": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "nativewind-env.d.ts",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}

================
File: types/chat.ts
================
export interface Chat {
  id: string;
  user: {
    id: string;
    first_name: string;
    avatar_url: string | null;
  };
  lastMessage: {
    content: string;
    created_at: string;
    is_mine: boolean;
  } | null;
  created_at: string;
}

================
File: types/env.d.ts
================
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      EXPO_PUBLIC_SUPABASE_URL: string;
      EXPO_PUBLIC_SUPABASE_ANON_KEY: string;
      EXPO_PUBLIC_TMDB_ACCESS_TOKEN: string;
    }
  }
}

export {};

================
File: types/matches.ts
================
import { Profile } from './users';

export interface Match {
  id: string;
  user1_id: string;
  user2_id: string;
  status: string;
  created_at: string;
  matched_user: Profile;
}

================
File: types/movies.ts
================
import { RealtimePostgresChangesPayload } from '@supabase/supabase-js';

export interface MovieData {
  id?: number;
  tmdb_id?: number;
  title: string;
  poster_path: string | null;
  backdrop_path: string | null;
  overview: string;
  release_date: string;
  vote_average: number;
}

export interface WatchedMovieData {
  movie_id: number;
  movies: MovieData;
  rating?: number;
  action: string;
  created_at: string;
}

export interface FilterOptions {
  year: {
    min: number;
    max: number;
  };
  genre: string[];
  imdbRating: {
    min: number;
    max: number;
  };
  userRating: {
    min: number;
    max: number;
  };
}

export type RatingPayload = RealtimePostgresChangesPayload<{
  movie_id: number;
  rating: number;
  user_id: string;
}>;

================
File: types/profile.ts
================
export interface Profile {
  id: string;
  first_name: string;
  avatar_url: string | null;
  updated_at?: string;
}

export interface ProfileUpdate {
  first_name?: string;
  avatar_url?: string | null;
}



================================================================
End of Codebase
================================================================
